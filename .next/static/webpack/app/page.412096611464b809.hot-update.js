"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/page",{

/***/ "(app-pages-browser)/./app/utils/DDLParser.ts":
/*!********************************!*\
  !*** ./app/utils/DDLParser.ts ***!
  \********************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": function() { return /* binding */ DDLParser; }\n/* harmony export */ });\n/* harmony import */ var uuid__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! uuid */ \"(app-pages-browser)/./node_modules/uuid/dist/esm-browser/v4.js\");\n\nclass DDLParser {\n    /**\n   * Main method to parse DDL and generate nodes and edges\n   * @returns Object containing nodes and edges\n   */ parse() {\n        // Split the DDL into separate statements\n        const statements = this.splitStatements(this.ddl);\n        // First pass: Create all table nodes\n        for (const statement of statements){\n            if (this.isCreateTableStatement(statement)) {\n                this.parseCreateTable(statement);\n            }\n        }\n        // Second pass: Handle foreign key relationships\n        for (const statement of statements){\n            if (this.isAlterTableAddForeignKey(statement)) {\n                this.parseForeignKeyConstraint(statement);\n            }\n        }\n        return {\n            nodes: this.nodes,\n            edges: this.edges\n        };\n    }\n    /**\n   * Split DDL into separate SQL statements\n   */ splitStatements(ddl) {\n        // Split by semicolons, but ignore semicolons inside quotes\n        const statements = [];\n        let currentStatement = \"\";\n        let inQuote = false;\n        let quoteChar = \"\";\n        for(let i = 0; i < ddl.length; i++){\n            const char = ddl[i];\n            // Handle quotes\n            if ((char === \"'\" || char === '\"') && (i === 0 || ddl[i - 1] !== \"\\\\\")) {\n                if (!inQuote) {\n                    inQuote = true;\n                    quoteChar = char;\n                } else if (char === quoteChar) {\n                    inQuote = false;\n                }\n            }\n            // Handle semicolons\n            if (char === \";\" && !inQuote) {\n                if (currentStatement.trim()) {\n                    statements.push(currentStatement.trim());\n                }\n                currentStatement = \"\";\n            } else {\n                currentStatement += char;\n            }\n        }\n        // Add the last statement if there's no trailing semicolon\n        if (currentStatement.trim()) {\n            statements.push(currentStatement.trim());\n        }\n        return statements;\n    }\n    /**\n   * Check if a statement is a CREATE TABLE statement\n   */ isCreateTableStatement(statement) {\n        return /CREATE\\s+(OR\\s+REPLACE\\s+)?(TABLE|VIEW|MATERIALIZED_VIEW|DYNAMIC_TABLE|ICEBERG_TABLE)\\s+/i.test(statement);\n    }\n    /**\n   * Check if a statement is an ALTER TABLE ADD FOREIGN KEY statement\n   */ isAlterTableAddForeignKey(statement) {\n        return /ALTER\\s+TABLE.*ADD\\s+(CONSTRAINT\\s+\\w+\\s+)?FOREIGN\\s+KEY/i.test(statement);\n    }\n    /**\n   * Parse a CREATE TABLE statement and add to nodes\n   */ parseCreateTable(statement) {\n        var _typeMatch_;\n        // Extract table type (TABLE, VIEW, etc.)\n        const typeMatch = statement.match(/CREATE\\s+(OR\\s+REPLACE\\s+)?(TABLE|VIEW|MATERIALIZED_VIEW|DYNAMIC_TABLE|ICEBERG_TABLE)\\s+/i);\n        const tableType = (typeMatch === null || typeMatch === void 0 ? void 0 : (_typeMatch_ = typeMatch[2]) === null || _typeMatch_ === void 0 ? void 0 : _typeMatch_.toUpperCase()) || \"TABLE\";\n        // Extract fully qualified table name - allow for quotes around each part or the whole name\n        // Format can be: \"DB\".\"SCHEMA\".\"TABLE\" or DB.SCHEMA.TABLE or combinations\n        const qualifiedNameRegex = /CREATE\\s+(OR\\s+REPLACE\\s+)?(TABLE|VIEW|MATERIALIZED_VIEW|DYNAMIC_TABLE|ICEBERG_TABLE)\\s+(?:(?:\"([^\"]+)\"|([a-zA-Z0-9_]+))(?:\\.(?:\"([^\"]+)\"|([a-zA-Z0-9_]+)))?(?:\\.(?:\"([^\"]+)\"|([a-zA-Z0-9_]+)))?|\"([^\"]+\\.[^\"]+(?:\\.[^\"]+)?)\"|([a-zA-Z0-9_]+\\.[a-zA-Z0-9_]+(?:\\.[a-zA-Z0-9_]+)?))/i;\n        const nameMatch = statement.match(qualifiedNameRegex);\n        if (!nameMatch) return;\n        // Extract the parts of the qualified name (database, schema, table)\n        let fullTableName = \"\";\n        let tableName = \"\";\n        // Check if we matched a fully quoted name like \"DB.SCHEMA.TABLE\"\n        if (nameMatch[9]) {\n            fullTableName = nameMatch[9];\n            const parts = fullTableName.split(\".\");\n            tableName = parts[parts.length - 1];\n        } else if (nameMatch[10]) {\n            fullTableName = nameMatch[10];\n            const parts = fullTableName.split(\".\");\n            tableName = parts[parts.length - 1];\n        } else {\n            const dbPart = nameMatch[3] || nameMatch[4] || \"\";\n            const schemaPart = nameMatch[5] || nameMatch[6] || \"\";\n            const tableNamePart = nameMatch[7] || nameMatch[8] || \"\";\n            if (tableNamePart) {\n                // We have a three-part name: DB.SCHEMA.TABLE\n                tableName = tableNamePart;\n                fullTableName = \"\".concat(dbPart, \".\").concat(schemaPart, \".\").concat(tableName);\n            } else if (schemaPart) {\n                // We have a two-part name: SCHEMA.TABLE\n                tableName = schemaPart;\n                fullTableName = \"\".concat(dbPart, \".\").concat(tableName);\n            } else {\n                // We have just a table name\n                tableName = dbPart;\n                fullTableName = tableName;\n            }\n        }\n        if (!tableName) return;\n        // Use the full name for display but keep the simple table name for internal reference\n        const normalizedTableName = tableName.toUpperCase();\n        // Extract columns from the statement\n        const columnsSection = this.extractColumnDefinitions(statement);\n        const columns = this.parseColumns(columnsSection, statement);\n        // Extract table comment if present\n        const commentMatch = statement.match(/COMMENT\\s*=\\s*'([^']*)'/i);\n        const comment = commentMatch ? commentMatch[1].replace(/''/, \"'\") : \"\";\n        // Extract tags if present\n        const tagsMatch = statement.match(/WITH\\s+TAG\\s+\\(([^)]*)\\)/i);\n        let tags = [];\n        if (tagsMatch) {\n            const tagsText = tagsMatch[1];\n            // Extract tag names from tag expressions like 'tag1' = 'true'\n            const tagRegex = /'([^']+)'\\s*=\\s*'true'/g;\n            let tagMatch;\n            while((tagMatch = tagRegex.exec(tagsText)) !== null){\n                tags.push(tagMatch[1]);\n            }\n        }\n        // Create the node\n        const nodeId = \"table-\".concat((0,uuid__WEBPACK_IMPORTED_MODULE_0__[\"default\"])());\n        this.tableNames.set(normalizedTableName, nodeId);\n        const node = {\n            id: nodeId,\n            type: \"table\",\n            position: {\n                x: Math.floor(Math.random() * 500),\n                y: Math.floor(Math.random() * 300)\n            },\n            data: {\n                label: fullTableName,\n                columns,\n                tableType: tableType,\n                comment,\n                tags\n            }\n        };\n        this.nodes.push(node);\n    }\n    /**\n   * Extract column definitions section from CREATE TABLE statement\n   */ extractColumnDefinitions(statement) {\n        // Get content between the first ( and the matching )\n        const startIdx = statement.indexOf(\"(\");\n        if (startIdx === -1) return \"\";\n        let depth = 1;\n        let endIdx = startIdx + 1;\n        for(let i = startIdx + 1; i < statement.length; i++){\n            if (statement[i] === \"(\") depth++;\n            else if (statement[i] === \")\") depth--;\n            if (depth === 0) {\n                endIdx = i;\n                break;\n            }\n        }\n        return statement.substring(startIdx + 1, endIdx).trim();\n    }\n    /**\n   * Parse column definitions into Column objects\n   */ parseColumns(columnsSection, fullStatement) {\n        const columns = [];\n        const lines = columnsSection.split(\",\\n\").map((line)=>line.trim());\n        let primaryKeyColumns = [];\n        // Extract primary key constraint if present\n        const primaryKeyMatch = columnsSection.match(/PRIMARY\\s+KEY\\s*\\(([^)]+)\\)/i);\n        if (primaryKeyMatch) {\n            primaryKeyColumns = primaryKeyMatch[1].split(\",\").map((col)=>col.trim().replace(/\"/g, \"\").toUpperCase());\n        }\n        // Process each column definition\n        for (const line of lines){\n            // Skip if line is a constraint definition\n            if (/^(PRIMARY|FOREIGN|UNIQUE)\\s+KEY/i.test(line)) continue;\n            // Extract column name\n            const nameMatch = line.match(/^(?:\"([^\"]+)\"|([a-zA-Z0-9_]+))\\s+/);\n            if (!nameMatch) continue;\n            const name = nameMatch[1] || nameMatch[2];\n            // Extract data type\n            const typeMatch = line.match(/\\s+([a-zA-Z0-9_]+(\\([^)]+\\))?)/);\n            const dataType = typeMatch ? typeMatch[1] : \"VARCHAR\";\n            // Check if column is nullable\n            const isNullable = !/NOT\\s+NULL/i.test(line);\n            // Check if column is a primary key\n            const isPrimaryKey = primaryKeyColumns.includes(name.toUpperCase());\n            // Extract comment if present\n            const commentMatch = line.match(/COMMENT\\s+'([^']*)'/i);\n            const comment = commentMatch ? commentMatch[1].replace(/''/, \"'\") : \"\";\n            // Parse column-level tags from full statement\n            let tags = [];\n            const tagRegex = new RegExp('ALTER\\\\s+TABLE.*MODIFY\\\\s+COLUMN\\\\s+(?:\"'.concat(name, '\"|').concat(name, \")\\\\s+SET\\\\s+TAG\\\\s+([^;]+)\"), \"i\");\n            const tagsMatch = fullStatement.match(tagRegex);\n            if (tagsMatch) {\n                const tagsText = tagsMatch[1];\n                // Extract tag names from tag expressions\n                const tagNameRegex = /'([^']+)'\\s*=\\s*'true'/g;\n                let tagMatch;\n                while((tagMatch = tagNameRegex.exec(tagsText)) !== null){\n                    tags.push(tagMatch[1]);\n                }\n            }\n            columns.push({\n                id: (0,uuid__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(),\n                name,\n                dataType,\n                isPrimaryKey,\n                isForeignKey: false,\n                isNullable,\n                comment,\n                tags\n            });\n        }\n        return columns;\n    }\n    /**\n   * Parse a foreign key constraint and create relationships\n   */ parseForeignKeyConstraint(statement) {\n        // Extract table name\n        const tableMatch = statement.match(/ALTER\\s+TABLE\\s+(?:\"([^\"]+)\"|([a-zA-Z0-9_]+))/i);\n        if (!tableMatch) return;\n        const tableName = (tableMatch[1] || tableMatch[2]).toUpperCase();\n        // Extract source columns\n        const sourceColsMatch = statement.match(/FOREIGN\\s+KEY\\s*\\(([^)]+)\\)/i);\n        if (!sourceColsMatch) return;\n        const sourceCols = sourceColsMatch[1].split(\",\").map((col)=>col.trim().replace(/\"/g, \"\").toUpperCase());\n        // Extract target table and columns\n        const refsMatch = statement.match(/REFERENCES\\s+(?:\"([^\"]+)\"|([a-zA-Z0-9_]+))\\s*\\(([^)]+)\\)/i);\n        if (!refsMatch) return;\n        const targetTable = (refsMatch[1] || refsMatch[2]).toUpperCase();\n        const targetCols = refsMatch[3].split(\",\").map((col)=>col.trim().replace(/\"/g, \"\").toUpperCase());\n        // If we have both source and target tables in our mapping\n        if (this.tableNames.has(tableName) && this.tableNames.has(targetTable)) {\n            const sourceId = this.tableNames.get(tableName);\n            const targetId = this.tableNames.get(targetTable);\n            // Update source columns to mark them as foreign keys\n            const sourceNode = this.nodes.find((node)=>node.id === sourceId);\n            if (sourceNode && sourceNode.type === \"table\" && sourceNode.data.columns) {\n                for(let i = 0; i < sourceCols.length && i < targetCols.length; i++){\n                    const columnName = sourceCols[i];\n                    const column = sourceNode.data.columns.find((col)=>col.name.toUpperCase() === columnName);\n                    if (column) {\n                        column.isForeignKey = true;\n                        column.referencedTable = targetTable;\n                        column.referencedColumn = targetCols[i];\n                    }\n                }\n            }\n            // Create an edge between the tables\n            const edge = {\n                id: \"e\".concat(sourceId, \"-\").concat(targetId, \"-\").concat((0,uuid__WEBPACK_IMPORTED_MODULE_0__[\"default\"])()),\n                source: sourceId,\n                target: targetId,\n                sourceHandle: \"\",\n                targetHandle: \"\",\n                type: \"relationship\",\n                data: {\n                    relationshipType: \"one-to-many\"\n                }\n            };\n            this.edges.push(edge);\n        }\n    }\n    constructor(ddl){\n        this.nodes = [];\n        this.edges = [];\n        this.tableNames = new Map() // Maps normalized table name to table ID\n        ;\n        this.ddl = ddl;\n    }\n}\n\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL2FwcC91dGlscy9ERExQYXJzZXIudHMiLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBb0M7QUFHckIsTUFBTUU7SUFVbkI7OztHQUdDLEdBQ0QsUUFBd0Q7UUFDdEQseUNBQXlDO1FBQ3pDLE1BQU1FLGFBQWEsSUFBSSxDQUFDQyxlQUFlLENBQUMsSUFBSSxDQUFDQyxHQUFHO1FBRWhELHFDQUFxQztRQUNyQyxLQUFLLE1BQU1DLGFBQWFILFdBQVk7WUFDbEMsSUFBSSxJQUFJLENBQUNJLHNCQUFzQixDQUFDRCxZQUFZO2dCQUMxQyxJQUFJLENBQUNFLGdCQUFnQixDQUFDRjtZQUN4QjtRQUNGO1FBRUEsZ0RBQWdEO1FBQ2hELEtBQUssTUFBTUEsYUFBYUgsV0FBWTtZQUNsQyxJQUFJLElBQUksQ0FBQ00seUJBQXlCLENBQUNILFlBQVk7Z0JBQzdDLElBQUksQ0FBQ0kseUJBQXlCLENBQUNKO1lBQ2pDO1FBQ0Y7UUFFQSxPQUFPO1lBQUVLLE9BQU8sSUFBSSxDQUFDQSxLQUFLO1lBQUVDLE9BQU8sSUFBSSxDQUFDQSxLQUFLO1FBQUM7SUFDaEQ7SUFFQTs7R0FFQyxHQUNELGdCQUF3QlAsR0FBVyxFQUFZO1FBQzdDLDJEQUEyRDtRQUMzRCxNQUFNRixhQUF1QixFQUFFO1FBQy9CLElBQUlVLG1CQUFtQjtRQUN2QixJQUFJQyxVQUFVO1FBQ2QsSUFBSUMsWUFBWTtRQUVoQixJQUFLLElBQUlDLElBQUksR0FBR0EsSUFBSVgsSUFBSVksTUFBTSxFQUFFRCxJQUFLO1lBQ25DLE1BQU1FLE9BQU9iLEdBQUcsQ0FBQ1csRUFBRTtZQUVuQixnQkFBZ0I7WUFDaEIsSUFBSSxDQUFDRSxTQUFTLE9BQU9BLFNBQVMsR0FBRSxLQUFPRixDQUFBQSxNQUFNLEtBQUtYLEdBQUcsQ0FBQ1csSUFBRSxFQUFFLEtBQUssSUFBRyxHQUFJO2dCQUNwRSxJQUFJLENBQUNGLFNBQVM7b0JBQ1pBLFVBQVU7b0JBQ1ZDLFlBQVlHO2dCQUNkLE9BQU8sSUFBSUEs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b0JBQ25FLE1BQU0rRSxhQUFhVixVQUFVLENBQUNyRSxFQUFFO29CQUNoQyxNQUFNZ0YsU0FBU0gsV0FBV2hDLElBQUksQ0FBQ3ZCLE9BQU8sQ0FBQ3dELElBQUksQ0FDekMsQ0FBQ3BCLE1BQWdCQSxJQUFJQyxJQUFJLENBQUNsRCxXQUFXLE9BQU9zRTtvQkFHOUMsSUFBSUMsUUFBUTt3QkFDVkEsT0FBT2QsWUFBWSxHQUFHO3dCQUN0QmMsT0FBT0MsZUFBZSxHQUFHVjt3QkFDekJTLE9BQU9FLGdCQUFnQixHQUFHVixVQUFVLENBQUN4RSxFQUFFO29CQUN6QztnQkFDRjtZQUNGO1lBRUEsb0NBQW9DO1lBQ3BDLE1BQU1tRixPQUFpQjtnQkFDckI5QyxJQUFJLElBQWdCdUMsT0FBWkYsVUFBUyxLQUFlMUYsT0FBWjRGLFVBQVMsS0FBWSxPQUFUNUYsZ0RBQU1BO2dCQUN0Q29HLFFBQVFWO2dCQUNSVyxRQUFRVDtnQkFDUlUsY0FBYztnQkFDZEMsY0FBYztnQkFDZGpELE1BQU07Z0JBQ05PLE1BQU07b0JBQUUyQyxrQkFBa0I7Z0JBQWM7WUFDMUM7WUFFQSxJQUFJLENBQUM1RixLQUFLLENBQUNRLElBQUksQ0FBQytFO1FBQ2xCO0lBQ0Y7SUExVkFNLFlBQVlwRyxHQUFXLENBQUU7YUFKakJNLFFBQW1CLEVBQUU7YUFDckJDLFFBQW9CLEVBQUU7YUFDdEJzQyxhQUFrQyxJQUFJd0QsTUFBTyx5Q0FBeUM7O1FBRzVGLElBQUksQ0FBQ3JHLEdBQUcsR0FBR0E7SUFDYjtBQXlWRjtBQUFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL2FwcC91dGlscy9ERExQYXJzZXIudHM/MThhZiJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyB2NCBhcyB1dWlkdjQgfSBmcm9tICd1dWlkJztcbmltcG9ydCB7IEVSRE5vZGUsIEVkZ2VUeXBlLCBDb2x1bW4gfSBmcm9tICcuL3R5cGVzJztcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgRERMUGFyc2VyIHtcbiAgcHJpdmF0ZSBkZGw6IHN0cmluZztcbiAgcHJpdmF0ZSBub2RlczogRVJETm9kZVtdID0gW107XG4gIHByaXZhdGUgZWRnZXM6IEVkZ2VUeXBlW10gPSBbXTtcbiAgcHJpdmF0ZSB0YWJsZU5hbWVzOiBNYXA8c3RyaW5nLCBzdHJpbmc+ID0gbmV3IE1hcCgpOyAvLyBNYXBzIG5vcm1hbGl6ZWQgdGFibGUgbmFtZSB0byB0YWJsZSBJRFxuXG4gIGNvbnN0cnVjdG9yKGRkbDogc3RyaW5nKSB7XG4gICAgdGhpcy5kZGwgPSBkZGw7XG4gIH1cblxuICAvKipcbiAgICogTWFpbiBtZXRob2QgdG8gcGFyc2UgRERMIGFuZCBnZW5lcmF0ZSBub2RlcyBhbmQgZWRnZXNcbiAgICogQHJldHVybnMgT2JqZWN0IGNvbnRhaW5pbmcgbm9kZXMgYW5kIGVkZ2VzXG4gICAqL1xuICBwdWJsaWMgcGFyc2UoKTogeyBub2RlczogRVJETm9kZVtdLCBlZGdlczogRWRnZVR5cGVbXSB9IHtcbiAgICAvLyBTcGxpdCB0aGUgRERMIGludG8gc2VwYXJhdGUgc3RhdGVtZW50c1xuICAgIGNvbnN0IHN0YXRlbWVudHMgPSB0aGlzLnNwbGl0U3RhdGVtZW50cyh0aGlzLmRkbCk7XG4gICAgXG4gICAgLy8gRmlyc3QgcGFzczogQ3JlYXRlIGFsbCB0YWJsZSBub2Rlc1xuICAgIGZvciAoY29uc3Qgc3RhdGVtZW50IG9mIHN0YXRlbWVudHMpIHtcbiAgICAgIGlmICh0aGlzLmlzQ3JlYXRlVGFibGVTdGF0ZW1lbnQoc3RhdGVtZW50KSkge1xuICAgICAgICB0aGlzLnBhcnNlQ3JlYXRlVGFibGUoc3RhdGVtZW50KTtcbiAgICAgIH1cbiAgICB9XG4gICAgXG4gICAgLy8gU2Vjb25kIHBhc3M6IEhhbmRsZSBmb3JlaWduIGtleSByZWxhdGlvbnNoaXBzXG4gICAgZm9yIChjb25zdCBzdGF0ZW1lbnQgb2Ygc3RhdGVtZW50cykge1xuICAgICAgaWYgKHRoaXMuaXNBbHRlclRhYmxlQWRkRm9yZWlnbktleShzdGF0ZW1lbnQpKSB7XG4gICAgICAgIHRoaXMucGFyc2VGb3JlaWduS2V5Q29uc3RyYWludChzdGF0ZW1lbnQpO1xuICAgICAgfVxuICAgIH1cbiAgICBcbiAgICByZXR1cm4geyBub2RlczogdGhpcy5ub2RlcywgZWRnZXM6IHRoaXMuZWRnZXMgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTcGxpdCBEREwgaW50byBzZXBhcmF0ZSBTUUwgc3RhdGVtZW50c1xuICAgKi9cbiAgcHJpdmF0ZSBzcGxpdFN0YXRlbWVudHMoZGRsOiBzdHJpbmcpOiBzdHJpbmdbXSB7XG4gICAgLy8gU3BsaXQgYnkgc2VtaWNvbG9ucywgYnV0IGlnbm9yZSBzZW1pY29sb25zIGluc2lkZSBxdW90ZXNcbiAgICBjb25zdCBzdGF0ZW1lbnRzOiBzdHJpbmdbXSA9IFtdO1xuICAgIGxldCBjdXJyZW50U3RhdGVtZW50ID0gJyc7XG4gICAgbGV0IGluUXVvdGUgPSBmYWxzZTtcbiAgICBsZXQgcXVvdGVDaGFyID0gJyc7XG4gICAgXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBkZGwubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IGNoYXIgPSBkZGxbaV07XG4gICAgICBcbiAgICAgIC8vIEhhbmRsZSBxdW90ZXNcbiAgICAgIGlmICgoY2hhciA9PT0gXCInXCIgfHwgY2hhciA9PT0gJ1wiJykgJiYgKGkgPT09IDAgfHwgZGRsW2ktMV0gIT09ICdcXFxcJykpIHtcbiAgICAgICAgaWYgKCFpblF1b3RlKSB7XG4gICAgICAgICAgaW5RdW90ZSA9IHRydWU7XG4gICAgICAgICAgcXVvdGVDaGFyID0gY2hhcjtcbiAgICAgICAgfSBlbHNlIGlmIChjaGFyID09PSBxdW90ZUNoYXIpIHtcbiAgICAgICAgICBpblF1b3RlID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIFxuICAgICAgLy8gSGFuZGxlIHNlbWljb2xvbnNcbiAgICAgIGlmIChjaGFyID09PSAnOycgJiYgIWluUXVvdGUpIHtcbiAgICAgICAgaWYgKGN1cnJlbnRTdGF0ZW1lbnQudHJpbSgpKSB7XG4gICAgICAgICAgc3RhdGVtZW50cy5wdXNoKGN1cnJlbnRTdGF0ZW1lbnQudHJpbSgpKTtcbiAgICAgICAgfVxuICAgICAgICBjdXJyZW50U3RhdGVtZW50ID0gJyc7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjdXJyZW50U3RhdGVtZW50ICs9IGNoYXI7XG4gICAgICB9XG4gICAgfVxuICAgIFxuICAgIC8vIEFkZCB0aGUgbGFzdCBzdGF0ZW1lbnQgaWYgdGhlcmUncyBubyB0cmFpbGluZyBzZW1pY29sb25cbiAgICBpZiAoY3VycmVudFN0YXRlbWVudC50cmltKCkpIHtcbiAgICAgIHN0YXRlbWVudHMucHVzaChjdXJyZW50U3RhdGVtZW50LnRyaW0oKSk7XG4gICAgfVxuICAgIFxuICAgIHJldHVybiBzdGF0ZW1lbnRzO1xuICB9XG5cbiAgLyoqXG4gICAqIENoZWNrIGlmIGEgc3RhdGVtZW50IGlzIGEgQ1JFQVRFIFRBQkxFIHN0YXRlbWVudFxuICAgKi9cbiAgcHJpdmF0ZSBpc0NyZWF0ZVRhYmxlU3RhdGVtZW50KHN0YXRlbWVudDogc3RyaW5nKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIC9DUkVBVEVcXHMrKE9SXFxzK1JFUExBQ0VcXHMrKT8oVEFCTEV8VklFV3xNQVRFUklBTElaRURfVklFV3xEWU5BTUlDX1RBQkxFfElDRUJFUkdfVEFCTEUpXFxzKy9pLnRlc3Qoc3RhdGVtZW50KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDaGVjayBpZiBhIHN0YXRlbWVudCBpcyBhbiBBTFRFUiBUQUJMRSBBREQgRk9SRUlHTiBLRVkgc3RhdGVtZW50XG4gICAqL1xuICBwcml2YXRlIGlzQWx0ZXJUYWJsZUFkZEZvcmVpZ25LZXkoc3RhdGVtZW50OiBzdHJpbmcpOiBib29sZWFuIHtcbiAgICByZXR1cm4gL0FMVEVSXFxzK1RBQkxFLipBRERcXHMrKENPTlNUUkFJTlRcXHMrXFx3K1xccyspP0ZPUkVJR05cXHMrS0VZL2kudGVzdChzdGF0ZW1lbnQpO1xuICB9XG5cbiAgLyoqXG4gICAqIFBhcnNlIGEgQ1JFQVRFIFRBQkxFIHN0YXRlbWVudCBhbmQgYWRkIHRvIG5vZGVzXG4gICAqL1xuICBwcml2YXRlIHBhcnNlQ3JlYXRlVGFibGUoc3RhdGVtZW50OiBzdHJpbmcpOiB2b2lkIHtcbiAgICAvLyBFeHRyYWN0IHRhYmxlIHR5cGUgKFRBQkxFLCBWSUVXLCBldGMuKVxuICAgIGNvbnN0IHR5cGVNYXRjaCA9IHN0YXRlbWVudC5tYXRjaCgvQ1JFQVRFXFxzKyhPUlxccytSRVBMQUNFXFxzKyk/KFRBQkxFfFZJRVd8TUFURVJJQUxJWkVEX1ZJRVd8RFlOQU1JQ19UQUJMRXxJQ0VCRVJHX1RBQkxFKVxccysvaSk7XG4gICAgY29uc3QgdGFibGVUeXBlID0gdHlwZU1hdGNoPy5bMl0/LnRvVXBwZXJDYXNlKCkgfHwgJ1RBQkxFJztcbiAgICBcbiAgICAvLyBFeHRyYWN0IGZ1bGx5IHF1YWxpZmllZCB0YWJsZSBuYW1lIC0gYWxsb3cgZm9yIHF1b3RlcyBhcm91bmQgZWFjaCBwYXJ0IG9yIHRoZSB3aG9sZSBuYW1lXG4gICAgLy8gRm9ybWF0IGNhbiBiZTogXCJEQlwiLlwiU0NIRU1BXCIuXCJUQUJMRVwiIG9yIERCLlNDSEVNQS5UQUJMRSBvciBjb21iaW5hdGlvbnNcbiAgICBjb25zdCBxdWFsaWZpZWROYW1lUmVnZXggPSAvQ1JFQVRFXFxzKyhPUlxccytSRVBMQUNFXFxzKyk/KFRBQkxFfFZJRVd8TUFURVJJQUxJWkVEX1ZJRVd8RFlOQU1JQ19UQUJMRXxJQ0VCRVJHX1RBQkxFKVxccysoPzooPzpcIihbXlwiXSspXCJ8KFthLXpBLVowLTlfXSspKSg/OlxcLig/OlwiKFteXCJdKylcInwoW2EtekEtWjAtOV9dKykpKT8oPzpcXC4oPzpcIihbXlwiXSspXCJ8KFthLXpBLVowLTlfXSspKSk/fFwiKFteXCJdK1xcLlteXCJdKyg/OlxcLlteXCJdKyk/KVwifChbYS16QS1aMC05X10rXFwuW2EtekEtWjAtOV9dKyg/OlxcLlthLXpBLVowLTlfXSspPykpL2k7XG4gICAgXG4gICAgY29uc3QgbmFtZU1hdGNoID0gc3RhdGVtZW50Lm1hdGNoKHF1YWxpZmllZE5hbWVSZWdleCk7XG4gICAgXG4gICAgaWYgKCFuYW1lTWF0Y2gpIHJldHVybjtcbiAgICBcbiAgICAvLyBFeHRyYWN0IHRoZSBwYXJ0cyBvZiB0aGUgcXVhbGlmaWVkIG5hbWUgKGRhdGFiYXNlLCBzY2hlbWEsIHRhYmxlKVxuICAgIGxldCBmdWxsVGFibGVOYW1lID0gJyc7XG4gICAgbGV0IHRhYmxlTmFtZSA9ICcnO1xuICAgIFxuICAgIC8vIENoZWNrIGlmIHdlIG1hdGNoZWQgYSBmdWxseSBxdW90ZWQgbmFtZSBsaWtlIFwiREIuU0NIRU1BLlRBQkxFXCJcbiAgICBpZiAobmFtZU1hdGNoWzldKSB7XG4gICAgICBmdWxsVGFibGVOYW1lID0gbmFtZU1hdGNoWzldO1xuICAgICAgY29uc3QgcGFydHMgPSBmdWxsVGFibGVOYW1lLnNwbGl0KCcuJyk7XG4gICAgICB0YWJsZU5hbWUgPSBwYXJ0c1twYXJ0cy5sZW5ndGggLSAxXTtcbiAgICB9IFxuICAgIC8vIENoZWNrIGlmIHdlIG1hdGNoZWQgYW4gdW5xdW90ZWQgZnVsbHkgcXVhbGlmaWVkIG5hbWUgbGlrZSBEQi5TQ0hFTUEuVEFCTEVcbiAgICBlbHNlIGlmIChuYW1lTWF0Y2hbMTBdKSB7XG4gICAgICBmdWxsVGFibGVOYW1lID0gbmFtZU1hdGNoWzEwXTtcbiAgICAgIGNvbnN0IHBhcnRzID0gZnVsbFRhYmxlTmFtZS5zcGxpdCgnLicpO1xuICAgICAgdGFibGVOYW1lID0gcGFydHNbcGFydHMubGVuZ3RoIC0gMV07XG4gICAgfVxuICAgIC8vIE90aGVyd2lzZSwgYnVpbGQgZnJvbSB0aGUgaW5kaXZpZHVhbCBwYXJ0c1xuICAgIGVsc2Uge1xuICAgICAgY29uc3QgZGJQYXJ0ID0gbmFtZU1hdGNoWzNdIHx8IG5hbWVNYXRjaFs0XSB8fCAnJztcbiAgICAgIGNvbnN0IHNjaGVtYVBhcnQgPSBuYW1lTWF0Y2hbNV0gfHwgbmFtZU1hdGNoWzZdIHx8ICcnO1xuICAgICAgY29uc3QgdGFibGVOYW1lUGFydCA9IG5hbWVNYXRjaFs3XSB8fCBuYW1lTWF0Y2hbOF0gfHwgJyc7XG4gICAgICBcbiAgICAgIGlmICh0YWJsZU5hbWVQYXJ0KSB7XG4gICAgICAgIC8vIFdlIGhhdmUgYSB0aHJlZS1wYXJ0IG5hbWU6IERCLlNDSEVNQS5UQUJMRVxuICAgICAgICB0YWJsZU5hbWUgPSB0YWJsZU5hbWVQYXJ0O1xuICAgICAgICBmdWxsVGFibGVOYW1lID0gYCR7ZGJQYXJ0fS4ke3NjaGVtYVBhcnR9LiR7dGFibGVOYW1lfWA7XG4gICAgICB9IGVsc2UgaWYgKHNjaGVtYVBhcnQpIHtcbiAgICAgICAgLy8gV2UgaGF2ZSBhIHR3by1wYXJ0IG5hbWU6IFNDSEVNQS5UQUJMRVxuICAgICAgICB0YWJsZU5hbWUgPSBzY2hlbWFQYXJ0O1xuICAgICAgICBmdWxsVGFibGVOYW1lID0gYCR7ZGJQYXJ0fS4ke3RhYmxlTmFtZX1gO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gV2UgaGF2ZSBqdXN0IGEgdGFibGUgbmFtZVxuICAgICAgICB0YWJsZU5hbWUgPSBkYlBhcnQ7XG4gICAgICAgIGZ1bGxUYWJsZU5hbWUgPSB0YWJsZU5hbWU7XG4gICAgICB9XG4gICAgfVxuICAgIFxuICAgIGlmICghdGFibGVOYW1lKSByZXR1cm47XG4gICAgXG4gICAgLy8gVXNlIHRoZSBmdWxsIG5hbWUgZm9yIGRpc3BsYXkgYnV0IGtlZXAgdGhlIHNpbXBsZSB0YWJsZSBuYW1lIGZvciBpbnRlcm5hbCByZWZlcmVuY2VcbiAgICBjb25zdCBub3JtYWxpemVkVGFibGVOYW1lID0gdGFibGVOYW1lLnRvVXBwZXJDYXNlKCk7XG4gICAgXG4gICAgLy8gRXh0cmFjdCBjb2x1bW5zIGZyb20gdGhlIHN0YXRlbWVudFxuICAgIGNvbnN0IGNvbHVtbnNTZWN0aW9uID0gdGhpcy5leHRyYWN0Q29sdW1uRGVmaW5pdGlvbnMoc3RhdGVtZW50KTtcbiAgICBjb25zdCBjb2x1bW5zID0gdGhpcy5wYXJzZUNvbHVtbnMoY29sdW1uc1NlY3Rpb24sIHN0YXRlbWVudCk7XG4gICAgXG4gICAgLy8gRXh0cmFjdCB0YWJsZSBjb21tZW50IGlmIHByZXNlbnRcbiAgICBjb25zdCBjb21tZW50TWF0Y2ggPSBzdGF0ZW1lbnQubWF0Y2goL0NPTU1FTlRcXHMqPVxccyonKFteJ10qKScvaSk7XG4gICAgY29uc3QgY29tbWVudCA9IGNvbW1lbnRNYXRjaCA/IGNvbW1lbnRNYXRjaFsxXS5yZXBsYWNlKC8nJy8sIFwiJ1wiKSA6ICcnO1xuICAgIFxuICAgIC8vIEV4dHJhY3QgdGFncyBpZiBwcmVzZW50XG4gICAgY29uc3QgdGFnc01hdGNoID0gc3RhdGVtZW50Lm1hdGNoKC9XSVRIXFxzK1RBR1xccytcXCgoW14pXSopXFwpL2kpO1xuICAgIGxldCB0YWdzOiBzdHJpbmdbXSA9IFtdO1xuICAgIFxuICAgIGlmICh0YWdzTWF0Y2gpIHtcbiAgICAgIGNvbnN0IHRhZ3NUZXh0ID0gdGFnc01hdGNoWzFdO1xuICAgICAgLy8gRXh0cmFjdCB0YWcgbmFtZXMgZnJvbSB0YWcgZXhwcmVzc2lvbnMgbGlrZSAndGFnMScgPSAndHJ1ZSdcbiAgICAgIGNvbnN0IHRhZ1JlZ2V4ID0gLycoW14nXSspJ1xccyo9XFxzKid0cnVlJy9nO1xuICAgICAgbGV0IHRhZ01hdGNoO1xuICAgICAgd2hpbGUgKCh0YWdNYXRjaCA9IHRhZ1JlZ2V4LmV4ZWModGFnc1RleHQpKSAhPT0gbnVsbCkge1xuICAgICAgICB0YWdzLnB1c2godGFnTWF0Y2hbMV0pO1xuICAgICAgfVxuICAgIH1cbiAgICBcbiAgICAvLyBDcmVhdGUgdGhlIG5vZGVcbiAgICBjb25zdCBub2RlSWQgPSBgdGFibGUtJHt1dWlkdjQoKX1gO1xuICAgIHRoaXMudGFibGVOYW1lcy5zZXQobm9ybWFsaXplZFRhYmxlTmFtZSwgbm9kZUlkKTtcbiAgICBcbiAgICBjb25zdCBub2RlOiBFUkROb2RlID0ge1xuICAgICAgaWQ6IG5vZGVJZCxcbiAgICAgIHR5cGU6ICd0YWJsZScsXG4gICAgICBwb3NpdGlvbjoge1xuICAgICAgICB4OiBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiA1MDApLFxuICAgICAgICB5OiBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiAzMDApLFxuICAgICAgfSxcbiAgICAgIGRhdGE6IHtcbiAgICAgICAgbGFiZWw6IGZ1bGxUYWJsZU5hbWUsXG4gICAgICAgIGNvbHVtbnMsXG4gICAgICAgIHRhYmxlVHlwZTogdGFibGVUeXBlIGFzIGFueSxcbiAgICAgICAgY29tbWVudCxcbiAgICAgICAgdGFnc1xuICAgICAgfVxuICAgIH07XG4gICAgXG4gICAgdGhpcy5ub2Rlcy5wdXNoKG5vZGUpO1xuICB9XG5cbiAgLyoqXG4gICAqIEV4dHJhY3QgY29sdW1uIGRlZmluaXRpb25zIHNlY3Rpb24gZnJvbSBDUkVBVEUgVEFCTEUgc3RhdGVtZW50XG4gICAqL1xuICBwcml2YXRlIGV4dHJhY3RDb2x1bW5EZWZpbml0aW9ucyhzdGF0ZW1lbnQ6IHN0cmluZyk6IHN0cmluZyB7XG4gICAgLy8gR2V0IGNvbnRlbnQgYmV0d2VlbiB0aGUgZmlyc3QgKCBhbmQgdGhlIG1hdGNoaW5nIClcbiAgICBjb25zdCBzdGFydElkeCA9IHN0YXRlbWVudC5pbmRleE9mKCcoJyk7XG4gICAgaWYgKHN0YXJ0SWR4ID09PSAtMSkgcmV0dXJuICcnO1xuICAgIFxuICAgIGxldCBkZXB0aCA9IDE7XG4gICAgbGV0IGVuZElkeCA9IHN0YXJ0SWR4ICsgMTtcbiAgICBcbiAgICBmb3IgKGxldCBpID0gc3RhcnRJZHggKyAxOyBpIDwgc3RhdGVtZW50Lmxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAoc3RhdGVtZW50W2ldID09PSAnKCcpIGRlcHRoKys7XG4gICAgICBlbHNlIGlmIChzdGF0ZW1lbnRbaV0gPT09ICcpJykgZGVwdGgtLTtcbiAgICAgIFxuICAgICAgaWYgKGRlcHRoID09PSAwKSB7XG4gICAgICAgIGVuZElkeCA9IGk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgICBcbiAgICByZXR1cm4gc3RhdGVtZW50LnN1YnN0cmluZyhzdGFydElkeCArIDEsIGVuZElkeCkudHJpbSgpO1xuICB9XG5cbiAgLyoqXG4gICAqIFBhcnNlIGNvbHVtbiBkZWZpbml0aW9ucyBpbnRvIENvbHVtbiBvYmplY3RzXG4gICAqL1xuICBwcml2YXRlIHBhcnNlQ29sdW1ucyhjb2x1bW5zU2VjdGlvbjogc3RyaW5nLCBmdWxsU3RhdGVtZW50OiBzdHJpbmcpOiBDb2x1bW5bXSB7XG4gICAgY29uc3QgY29sdW1uczogQ29sdW1uW10gPSBbXTtcbiAgICBjb25zdCBsaW5lcyA9IGNvbHVtbnNTZWN0aW9uLnNwbGl0KCcsXFxuJykubWFwKGxpbmUgPT4gbGluZS50cmltKCkpO1xuICAgIFxuICAgIGxldCBwcmltYXJ5S2V5Q29sdW1uczogc3RyaW5nW10gPSBbXTtcbiAgICBcbiAgICAvLyBFeHRyYWN0IHByaW1hcnkga2V5IGNvbnN0cmFpbnQgaWYgcHJlc2VudFxuICAgIGNvbnN0IHByaW1hcnlLZXlNYXRjaCA9IGNvbHVtbnNTZWN0aW9uLm1hdGNoKC9QUklNQVJZXFxzK0tFWVxccypcXCgoW14pXSspXFwpL2kpO1xuICAgIGlmIChwcmltYXJ5S2V5TWF0Y2gpIHtcbiAgICAgIHByaW1hcnlLZXlDb2x1bW5zID0gcHJpbWFyeUtleU1hdGNoWzFdXG4gICAgICAgIC5zcGxpdCgnLCcpXG4gICAgICAgIC5tYXAoY29sID0+IGNvbC50cmltKCkucmVwbGFjZSgvXCIvZywgJycpLnRvVXBwZXJDYXNlKCkpO1xuICAgIH1cbiAgICBcbiAgICAvLyBQcm9jZXNzIGVhY2ggY29sdW1uIGRlZmluaXRpb25cbiAgICBmb3IgKGNvbnN0IGxpbmUgb2YgbGluZXMpIHtcbiAgICAgIC8vIFNraXAgaWYgbGluZSBpcyBhIGNvbnN0cmFpbnQgZGVmaW5pdGlvblxuICAgICAgaWYgKC9eKFBSSU1BUll8Rk9SRUlHTnxVTklRVUUpXFxzK0tFWS9pLnRlc3QobGluZSkpIGNvbnRpbnVlO1xuICAgICAgXG4gICAgICAvLyBFeHRyYWN0IGNvbHVtbiBuYW1lXG4gICAgICBjb25zdCBuYW1lTWF0Y2ggPSBsaW5lLm1hdGNoKC9eKD86XCIoW15cIl0rKVwifChbYS16QS1aMC05X10rKSlcXHMrLyk7XG4gICAgICBpZiAoIW5hbWVNYXRjaCkgY29udGludWU7XG4gICAgICBcbiAgICAgIGNvbnN0IG5hbWUgPSBuYW1lTWF0Y2hbMV0gfHwgbmFtZU1hdGNoWzJdO1xuICAgICAgXG4gICAgICAvLyBFeHRyYWN0IGRhdGEgdHlwZVxuICAgICAgY29uc3QgdHlwZU1hdGNoID0gbGluZS5tYXRjaCgvXFxzKyhbYS16QS1aMC05X10rKFxcKFteKV0rXFwpKT8pLyk7XG4gICAgICBjb25zdCBkYXRhVHlwZSA9IHR5cGVNYXRjaCA/IHR5cGVNYXRjaFsxXSA6ICdWQVJDSEFSJztcbiAgICAgIFxuICAgICAgLy8gQ2hlY2sgaWYgY29sdW1uIGlzIG51bGxhYmxlXG4gICAgICBjb25zdCBpc051bGxhYmxlID0gIS9OT1RcXHMrTlVMTC9pLnRlc3QobGluZSk7XG4gICAgICBcbiAgICAgIC8vIENoZWNrIGlmIGNvbHVtbiBpcyBhIHByaW1hcnkga2V5XG4gICAgICBjb25zdCBpc1ByaW1hcnlLZXkgPSBwcmltYXJ5S2V5Q29sdW1ucy5pbmNsdWRlcyhuYW1lLnRvVXBwZXJDYXNlKCkpO1xuICAgICAgXG4gICAgICAvLyBFeHRyYWN0IGNvbW1lbnQgaWYgcHJlc2VudFxuICAgICAgY29uc3QgY29tbWVudE1hdGNoID0gbGluZS5tYXRjaCgvQ09NTUVOVFxccysnKFteJ10qKScvaSk7XG4gICAgICBjb25zdCBjb21tZW50ID0gY29tbWVudE1hdGNoID8gY29tbWVudE1hdGNoWzFdLnJlcGxhY2UoLycnLywgXCInXCIpIDogJyc7XG4gICAgICBcbiAgICAgIC8vIFBhcnNlIGNvbHVtbi1sZXZlbCB0YWdzIGZyb20gZnVsbCBzdGF0ZW1lbnRcbiAgICAgIGxldCB0YWdzOiBzdHJpbmdbXSA9IFtdO1xuICAgICAgY29uc3QgdGFnUmVnZXggPSBuZXcgUmVnRXhwKGBBTFRFUlxcXFxzK1RBQkxFLipNT0RJRllcXFxccytDT0xVTU5cXFxccysoPzpcIiR7bmFtZX1cInwke25hbWV9KVxcXFxzK1NFVFxcXFxzK1RBR1xcXFxzKyhbXjtdKylgLCAnaScpO1xuICAgICAgY29uc3QgdGFnc01hdGNoID0gZnVsbFN0YXRlbWVudC5tYXRjaCh0YWdSZWdleCk7XG4gICAgICBcbiAgICAgIGlmICh0YWdzTWF0Y2gpIHtcbiAgICAgICAgY29uc3QgdGFnc1RleHQgPSB0YWdzTWF0Y2hbMV07XG4gICAgICAgIC8vIEV4dHJhY3QgdGFnIG5hbWVzIGZyb20gdGFnIGV4cHJlc3Npb25zXG4gICAgICAgIGNvbnN0IHRhZ05hbWVSZWdleCA9IC8nKFteJ10rKSdcXHMqPVxccyondHJ1ZScvZztcbiAgICAgICAgbGV0IHRhZ01hdGNoO1xuICAgICAgICB3aGlsZSAoKHRhZ01hdGNoID0gdGFnTmFtZVJlZ2V4LmV4ZWModGFnc1RleHQpKSAhPT0gbnVsbCkge1xuICAgICAgICAgIHRhZ3MucHVzaCh0YWdNYXRjaFsxXSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIFxuICAgICAgY29sdW1ucy5wdXNoKHtcbiAgICAgICAgaWQ6IHV1aWR2NCgpLFxuICAgICAgICBuYW1lLFxuICAgICAgICBkYXRhVHlwZSxcbiAgICAgICAgaXNQcmltYXJ5S2V5LFxuICAgICAgICBpc0ZvcmVpZ25LZXk6IGZhbHNlLCAvLyBXaWxsIGJlIHNldCBpbiBzZWNvbmQgcGFzc1xuICAgICAgICBpc051bGxhYmxlLFxuICAgICAgICBjb21tZW50LFxuICAgICAgICB0YWdzXG4gICAgICB9KTtcbiAgICB9XG4gICAgXG4gICAgcmV0dXJuIGNvbHVtbnM7XG4gIH1cblxuICAvKipcbiAgICogUGFyc2UgYSBmb3JlaWduIGtleSBjb25zdHJhaW50IGFuZCBjcmVhdGUgcmVsYXRpb25zaGlwc1xuICAgKi9cbiAgcHJpdmF0ZSBwYXJzZUZvcmVpZ25LZXlDb25zdHJhaW50KHN0YXRlbWVudDogc3RyaW5nKTogdm9pZCB7XG4gICAgLy8gRXh0cmFjdCB0YWJsZSBuYW1lXG4gICAgY29uc3QgdGFibGVNYXRjaCA9IHN0YXRlbWVudC5tYXRjaCgvQUxURVJcXHMrVEFCTEVcXHMrKD86XCIoW15cIl0rKVwifChbYS16QS1aMC05X10rKSkvaSk7XG4gICAgaWYgKCF0YWJsZU1hdGNoKSByZXR1cm47XG4gICAgXG4gICAgY29uc3QgdGFibGVOYW1lID0gKHRhYmxlTWF0Y2hbMV0gfHwgdGFibGVNYXRjaFsyXSkudG9VcHBlckNhc2UoKTtcbiAgICBcbiAgICAvLyBFeHRyYWN0IHNvdXJjZSBjb2x1bW5zXG4gICAgY29uc3Qgc291cmNlQ29sc01hdGNoID0gc3RhdGVtZW50Lm1hdGNoKC9GT1JFSUdOXFxzK0tFWVxccypcXCgoW14pXSspXFwpL2kpO1xuICAgIGlmICghc291cmNlQ29sc01hdGNoKSByZXR1cm47XG4gICAgXG4gICAgY29uc3Qgc291cmNlQ29scyA9IHNvdXJjZUNvbHNNYXRjaFsxXVxuICAgICAgLnNwbGl0KCcsJylcbiAgICAgIC5tYXAoY29sID0+IGNvbC50cmltKCkucmVwbGFjZSgvXCIvZywgJycpLnRvVXBwZXJDYXNlKCkpO1xuICAgIFxuICAgIC8vIEV4dHJhY3QgdGFyZ2V0IHRhYmxlIGFuZCBjb2x1bW5zXG4gICAgY29uc3QgcmVmc01hdGNoID0gc3RhdGVtZW50Lm1hdGNoKC9SRUZFUkVOQ0VTXFxzKyg/OlwiKFteXCJdKylcInwoW2EtekEtWjAtOV9dKykpXFxzKlxcKChbXildKylcXCkvaSk7XG4gICAgaWYgKCFyZWZzTWF0Y2gpIHJldHVybjtcbiAgICBcbiAgICBjb25zdCB0YXJnZXRUYWJsZSA9IChyZWZzTWF0Y2hbMV0gfHwgcmVmc01hdGNoWzJdKS50b1VwcGVyQ2FzZSgpO1xuICAgIGNvbnN0IHRhcmdldENvbHMgPSByZWZzTWF0Y2hbM11cbiAgICAgIC5zcGxpdCgnLCcpXG4gICAgICAubWFwKGNvbCA9PiBjb2wudHJpbSgpLnJlcGxhY2UoL1wiL2csICcnKS50b1VwcGVyQ2FzZSgpKTtcbiAgICBcbiAgICAvLyBJZiB3ZSBoYXZlIGJvdGggc291cmNlIGFuZCB0YXJnZXQgdGFibGVzIGluIG91ciBtYXBwaW5nXG4gICAgaWYgKHRoaXMudGFibGVOYW1lcy5oYXModGFibGVOYW1lKSAmJiB0aGlzLnRhYmxlTmFtZXMuaGFzKHRhcmdldFRhYmxlKSkge1xuICAgICAgY29uc3Qgc291cmNlSWQgPSB0aGlzLnRhYmxlTmFtZXMuZ2V0KHRhYmxlTmFtZSkhO1xuICAgICAgY29uc3QgdGFyZ2V0SWQgPSB0aGlzLnRhYmxlTmFtZXMuZ2V0KHRhcmdldFRhYmxlKSE7XG4gICAgICBcbiAgICAgIC8vIFVwZGF0ZSBzb3VyY2UgY29sdW1ucyB0byBtYXJrIHRoZW0gYXMgZm9yZWlnbiBrZXlzXG4gICAgICBjb25zdCBzb3VyY2VOb2RlID0gdGhpcy5ub2Rlcy5maW5kKG5vZGUgPT4gbm9kZS5pZCA9PT0gc291cmNlSWQpO1xuICAgICAgaWYgKHNvdXJjZU5vZGUgJiYgc291cmNlTm9kZS50eXBlID09PSAndGFibGUnICYmIHNvdXJjZU5vZGUuZGF0YS5jb2x1bW5zKSB7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc291cmNlQ29scy5sZW5ndGggJiYgaSA8IHRhcmdldENvbHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBjb25zdCBjb2x1bW5OYW1lID0gc291cmNlQ29sc1tpXTtcbiAgICAgICAgICBjb25zdCBjb2x1bW4gPSBzb3VyY2VOb2RlLmRhdGEuY29sdW1ucy5maW5kKFxuICAgICAgICAgICAgKGNvbDogQ29sdW1uKSA9PiBjb2wubmFtZS50b1VwcGVyQ2FzZSgpID09PSBjb2x1bW5OYW1lXG4gICAgICAgICAgKTtcbiAgICAgICAgICBcbiAgICAgICAgICBpZiAoY29sdW1uKSB7XG4gICAgICAgICAgICBjb2x1bW4uaXNGb3JlaWduS2V5ID0gdHJ1ZTtcbiAgICAgICAgICAgIGNvbHVtbi5yZWZlcmVuY2VkVGFibGUgPSB0YXJnZXRUYWJsZTtcbiAgICAgICAgICAgIGNvbHVtbi5yZWZlcmVuY2VkQ29sdW1uID0gdGFyZ2V0Q29sc1tpXTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIFxuICAgICAgLy8gQ3JlYXRlIGFuIGVkZ2UgYmV0d2VlbiB0aGUgdGFibGVzXG4gICAgICBjb25zdCBlZGdlOiBFZGdlVHlwZSA9IHtcbiAgICAgICAgaWQ6IGBlJHtzb3VyY2VJZH0tJHt0YXJnZXRJZH0tJHt1dWlkdjQoKX1gLFxuICAgICAgICBzb3VyY2U6IHNvdXJjZUlkLFxuICAgICAgICB0YXJnZXQ6IHRhcmdldElkLFxuICAgICAgICBzb3VyY2VIYW5kbGU6ICcnLFxuICAgICAgICB0YXJnZXRIYW5kbGU6ICcnLFxuICAgICAgICB0eXBlOiAncmVsYXRpb25zaGlwJyxcbiAgICAgICAgZGF0YTogeyByZWxhdGlvbnNoaXBUeXBlOiAnb25lLXRvLW1hbnknIH1cbiAgICAgIH07XG4gICAgICBcbiAgICAgIHRoaXMuZWRnZXMucHVzaChlZGdlKTtcbiAgICB9XG4gIH1cbn0gIl0sIm5hbWVzIjpbInY0IiwidXVpZHY0IiwiRERMUGFyc2VyIiwicGFyc2UiLCJzdGF0ZW1lbnRzIiwic3BsaXRTdGF0ZW1lbnRzIiwiZGRsIiwic3RhdGVtZW50IiwiaXNDcmVhdGVUYWJsZVN0YXRlbWVudCIsInBhcnNlQ3JlYXRlVGFibGUiLCJpc0FsdGVyVGFibGVBZGRGb3JlaWduS2V5IiwicGFyc2VGb3JlaWduS2V5Q29uc3RyYWludCIsIm5vZGVzIiwiZWRnZXMiLCJjdXJyZW50U3RhdGVtZW50IiwiaW5RdW90ZSIsInF1b3RlQ2hhciIsImkiLCJsZW5ndGgiLCJjaGFyIiwidHJpbSIsInB1c2giLCJ0ZXN0IiwidHlwZU1hdGNoIiwibWF0Y2giLCJ0YWJsZVR5cGUiLCJ0b1VwcGVyQ2FzZSIsInF1YWxpZmllZE5hbWVSZWdleCIsIm5hbWVNYXRjaCIsImZ1bGxUYWJsZU5hbWUiLCJ0YWJsZU5hbWUiLCJwYXJ0cyIsInNwbGl0IiwiZGJQYXJ0Iiwic2NoZW1hUGFydCIsInRhYmxlTmFtZVBhcnQiLCJub3JtYWxpemVkVGFibGVOYW1lIiwiY29sdW1uc1NlY3Rpb24iLCJleHRyYWN0Q29sdW1uRGVmaW5pdGlvbnMiLCJjb2x1bW5zIiwicGFyc2VDb2x1bW5zIiwiY29tbWVudE1hdGNoIiwiY29tbWVudCIsInJlcGxhY2UiLCJ0YWdzTWF0Y2giLCJ0YWdzIiwidGFnc1RleHQiLCJ0YWdSZWdleCIsInRhZ01hdGNoIiwiZXhlYyIsIm5vZGVJZCIsInRhYmxlTmFtZXMiLCJzZXQiLCJub2RlIiwiaWQiLCJ0eXBlIiwicG9zaXRpb24iLCJ4IiwiTWF0aCIsImZsb29yIiwicmFuZG9tIiwieSIsImRhdGEiLCJsYWJlbCIsInN0YXJ0SWR4IiwiaW5kZXhPZiIsImRlcHRoIiwiZW5kSWR4Iiwic3Vic3RyaW5nIiwiZnVsbFN0YXRlbWVudCIsImxpbmVzIiwibWFwIiwibGluZSIsInByaW1hcnlLZXlDb2x1bW5zIiwicHJpbWFyeUtleU1hdGNoIiwiY29sIiwibmFtZSIsImRhdGFUeXBlIiwiaXNOdWxsYWJsZSIsImlzUHJpbWFyeUtleSIsImluY2x1ZGVzIiwiUmVnRXhwIiwidGFnTmFtZVJlZ2V4IiwiaXNGb3JlaWduS2V5IiwidGFibGVNYXRjaCIsInNvdXJjZUNvbHNNYXRjaCIsInNvdXJjZUNvbHMiLCJyZWZzTWF0Y2giLCJ0YXJnZXRUYWJsZSIsInRhcmdldENvbHMiLCJoYXMiLCJzb3VyY2VJZCIsImdldCIsInRhcmdldElkIiwic291cmNlTm9kZSIsImZpbmQiLCJjb2x1bW5OYW1lIiwiY29sdW1uIiwicmVmZXJlbmNlZFRhYmxlIiwicmVmZXJlbmNlZENvbHVtbiIsImVkZ2UiLCJzb3VyY2UiLCJ0YXJnZXQiLCJzb3VyY2VIYW5kbGUiLCJ0YXJnZXRIYW5kbGUiLCJyZWxhdGlvbnNoaXBUeXBlIiwiY29uc3RydWN0b3IiLCJNYXAiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./app/utils/DDLParser.ts\n"));

/***/ })

});