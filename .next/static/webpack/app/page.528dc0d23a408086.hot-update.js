"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/page",{

/***/ "(app-pages-browser)/./app/utils/DDLParser.ts":
/*!********************************!*\
  !*** ./app/utils/DDLParser.ts ***!
  \********************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": function() { return /* binding */ DDLParser; }\n/* harmony export */ });\n/* harmony import */ var uuid__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! uuid */ \"(app-pages-browser)/./node_modules/uuid/dist/esm-browser/v4.js\");\n\nclass DDLParser {\n    /**\n   * Main method to parse DDL and generate nodes and edges\n   * @returns Object containing nodes and edges\n   */ parse() {\n        // Split the DDL into separate statements\n        const statements = this.splitStatements(this.ddl);\n        console.log(\"Parsing \".concat(statements.length, \" SQL statements\"));\n        // First pass: Create all table nodes\n        for (const statement of statements){\n            if (this.isCreateTableStatement(statement)) {\n                this.parseCreateTable(statement);\n            }\n        }\n        // Second pass: Handle foreign key relationships\n        for (const statement of statements){\n            if (this.isAlterTableAddForeignKey(statement)) {\n                this.parseForeignKeyConstraint(statement);\n            }\n        }\n        console.log(\"Created \".concat(this.nodes.length, \" tables and \").concat(this.edges.length, \" relationships\"));\n        return {\n            nodes: this.nodes,\n            edges: this.edges\n        };\n    }\n    /**\n   * Split DDL into separate SQL statements\n   * Handles multiple statements separated by semicolons, accounting for quoted text\n   * and nested statements.\n   */ splitStatements(ddl) {\n        // Split by semicolons, but ignore semicolons inside quotes\n        const statements = [];\n        let currentStatement = \"\";\n        let inQuote = false;\n        let quoteChar = \"\";\n        let inComment = false;\n        for(let i = 0; i < ddl.length; i++){\n            const char = ddl[i];\n            const nextChar = i < ddl.length - 1 ? ddl[i + 1] : \"\";\n            // Handle line comments\n            if (!inQuote && char === \"-\" && nextChar === \"-\") {\n                inComment = true;\n            }\n            // End of line terminates comments\n            if (inComment && (char === \"\\n\" || char === \"\\r\")) {\n                inComment = false;\n            }\n            // Skip comment content but keep adding to current statement\n            if (inComment) {\n                currentStatement += char;\n                continue;\n            }\n            // Handle quotes\n            if ((char === \"'\" || char === '\"') && (i === 0 || ddl[i - 1] !== \"\\\\\")) {\n                if (!inQuote) {\n                    inQuote = true;\n                    quoteChar = char;\n                } else if (char === quoteChar) {\n                    inQuote = false;\n                }\n            }\n            // Handle semicolons\n            if (char === \";\" && !inQuote) {\n                if (currentStatement.trim()) {\n                    statements.push(currentStatement.trim());\n                }\n                currentStatement = \"\";\n            } else {\n                currentStatement += char;\n            }\n        }\n        // Add the last statement if there's no trailing semicolon\n        if (currentStatement.trim()) {\n            statements.push(currentStatement.trim());\n        }\n        // Filter out any empty statements\n        return statements.filter((stmt)=>stmt.trim().length > 0);\n    }\n    /**\n   * Check if a statement is a CREATE TABLE statement\n   */ isCreateTableStatement(statement) {\n        return /CREATE\\s+(OR\\s+REPLACE\\s+)?(TABLE|VIEW|MATERIALIZED_VIEW|DYNAMIC_TABLE|ICEBERG_TABLE)\\s+/i.test(statement);\n    }\n    /**\n   * Check if a statement is an ALTER TABLE ADD FOREIGN KEY statement\n   */ isAlterTableAddForeignKey(statement) {\n        return /ALTER\\s+TABLE.*ADD\\s+(CONSTRAINT\\s+\\w+\\s+)?FOREIGN\\s+KEY/i.test(statement);\n    }\n    /**\n   * Parse a CREATE TABLE statement and add to nodes\n   */ parseCreateTable(statement) {\n        var _typeMatch_;\n        // Extract table type (TABLE, VIEW, etc.)\n        const typeMatch = statement.match(/CREATE\\s+(OR\\s+REPLACE\\s+)?(TABLE|VIEW|MATERIALIZED_VIEW|DYNAMIC_TABLE|ICEBERG_TABLE)\\s+/i);\n        const tableType = (typeMatch === null || typeMatch === void 0 ? void 0 : (_typeMatch_ = typeMatch[2]) === null || _typeMatch_ === void 0 ? void 0 : _typeMatch_.toUpperCase()) || \"TABLE\";\n        // Extract fully qualified table name - allow for quotes around each part or the whole name\n        // Format can be: \"DB\".\"SCHEMA\".\"TABLE\" or DB.SCHEMA.TABLE or combinations\n        const qualifiedNameRegex = /CREATE\\s+(OR\\s+REPLACE\\s+)?(TABLE|VIEW|MATERIALIZED_VIEW|DYNAMIC_TABLE|ICEBERG_TABLE)\\s+(?:(?:\"([^\"]+)\"|([a-zA-Z0-9_]+))(?:\\.(?:\"([^\"]+)\"|([a-zA-Z0-9_]+)))?(?:\\.(?:\"([^\"]+)\"|([a-zA-Z0-9_]+)))?|\"([^\"]+\\.[^\"]+(?:\\.[^\"]+)?)\"|([a-zA-Z0-9_]+\\.[a-zA-Z0-9_]+(?:\\.[a-zA-Z0-9_]+)?))/i;\n        const nameMatch = statement.match(qualifiedNameRegex);\n        if (!nameMatch) return;\n        // Extract the parts of the qualified name (database, schema, table)\n        let fullTableName = \"\";\n        let tableName = \"\";\n        // Check if we matched a fully quoted name like \"DB.SCHEMA.TABLE\"\n        if (nameMatch[9]) {\n            fullTableName = nameMatch[9];\n            const parts = fullTableName.split(\".\");\n            tableName = parts[parts.length - 1];\n        } else if (nameMatch[10]) {\n            fullTableName = nameMatch[10];\n            const parts = fullTableName.split(\".\");\n            tableName = parts[parts.length - 1];\n        } else {\n            const dbPart = nameMatch[3] || nameMatch[4] || \"\";\n            const schemaPart = nameMatch[5] || nameMatch[6] || \"\";\n            const tableNamePart = nameMatch[7] || nameMatch[8] || \"\";\n            if (tableNamePart) {\n                // We have a three-part name: DB.SCHEMA.TABLE\n                tableName = tableNamePart;\n                fullTableName = \"\".concat(dbPart, \".\").concat(schemaPart, \".\").concat(tableName);\n            } else if (schemaPart) {\n                // We have a two-part name: SCHEMA.TABLE\n                tableName = schemaPart;\n                fullTableName = \"\".concat(dbPart, \".\").concat(tableName);\n            } else {\n                // We have just a table name\n                tableName = dbPart;\n                fullTableName = tableName;\n            }\n        }\n        if (!tableName) return;\n        // Use the full name for display but keep the simple table name for internal reference\n        const normalizedTableName = tableName.toUpperCase();\n        // Extract columns from the statement\n        const columnsSection = this.extractColumnDefinitions(statement);\n        const columns = this.parseColumns(columnsSection, statement);\n        // Extract table comment if present\n        const commentMatch = statement.match(/COMMENT\\s*=\\s*'([^']*)'/i);\n        const comment = commentMatch ? commentMatch[1].replace(/''/, \"'\") : \"\";\n        // Extract tags if present\n        const tagsMatch = statement.match(/WITH\\s+TAG\\s+\\(([^)]*)\\)/i);\n        let tags = [];\n        if (tagsMatch) {\n            const tagsText = tagsMatch[1];\n            // Extract tag names from tag expressions like 'tag1' = 'true'\n            const tagRegex = /'([^']+)'\\s*=\\s*'true'/g;\n            let tagMatch;\n            while((tagMatch = tagRegex.exec(tagsText)) !== null){\n                tags.push(tagMatch[1]);\n            }\n        }\n        // Create the node\n        const nodeId = \"table-\".concat((0,uuid__WEBPACK_IMPORTED_MODULE_0__[\"default\"])());\n        this.tableNames.set(normalizedTableName, nodeId);\n        const node = {\n            id: nodeId,\n            type: \"table\",\n            position: {\n                x: Math.floor(Math.random() * 500),\n                y: Math.floor(Math.random() * 300)\n            },\n            data: {\n                label: fullTableName,\n                columns,\n                tableType: tableType,\n                comment,\n                tags\n            }\n        };\n        this.nodes.push(node);\n    }\n    /**\n   * Extract column definitions section from CREATE TABLE statement\n   */ extractColumnDefinitions(statement) {\n        // Get content between the first ( and the matching )\n        const startIdx = statement.indexOf(\"(\");\n        if (startIdx === -1) return \"\";\n        let depth = 1;\n        let endIdx = startIdx + 1;\n        for(let i = startIdx + 1; i < statement.length; i++){\n            if (statement[i] === \"(\") depth++;\n            else if (statement[i] === \")\") depth--;\n            if (depth === 0) {\n                endIdx = i;\n                break;\n            }\n        }\n        return statement.substring(startIdx + 1, endIdx).trim();\n    }\n    /**\n   * Parse column definitions into Column objects\n   */ parseColumns(columnsSection, fullStatement) {\n        const columns = [];\n        const lines = columnsSection.split(\",\\n\").map((line)=>line.trim());\n        let primaryKeyColumns = [];\n        // Extract primary key constraint if present\n        const primaryKeyMatch = columnsSection.match(/PRIMARY\\s+KEY\\s*\\(([^)]+)\\)/i);\n        if (primaryKeyMatch) {\n            primaryKeyColumns = primaryKeyMatch[1].split(\",\").map((col)=>col.trim().replace(/\"/g, \"\").toUpperCase());\n        }\n        // Process each column definition\n        for (const line of lines){\n            // Skip if line is a constraint definition\n            if (/^(PRIMARY|FOREIGN|UNIQUE)\\s+KEY/i.test(line)) continue;\n            // Extract column name\n            const nameMatch = line.match(/^(?:\"([^\"]+)\"|([a-zA-Z0-9_]+))\\s+/);\n            if (!nameMatch) continue;\n            const name = nameMatch[1] || nameMatch[2];\n            // Extract data type\n            const typeMatch = line.match(/\\s+([a-zA-Z0-9_]+(\\([^)]+\\))?)/);\n            const dataType = typeMatch ? typeMatch[1] : \"VARCHAR\";\n            // Check if column is nullable\n            const isNullable = !/NOT\\s+NULL/i.test(line);\n            // Check if column is a primary key\n            const isPrimaryKey = primaryKeyColumns.includes(name.toUpperCase());\n            // Extract comment if present\n            const commentMatch = line.match(/COMMENT\\s+'([^']*)'/i);\n            const comment = commentMatch ? commentMatch[1].replace(/''/, \"'\") : \"\";\n            // Parse column-level tags from full statement\n            let tags = [];\n            const tagRegex = new RegExp('ALTER\\\\s+TABLE.*MODIFY\\\\s+COLUMN\\\\s+(?:\"'.concat(name, '\"|').concat(name, \")\\\\s+SET\\\\s+TAG\\\\s+([^;]+)\"), \"i\");\n            const tagsMatch = fullStatement.match(tagRegex);\n            if (tagsMatch) {\n                const tagsText = tagsMatch[1];\n                // Extract tag names from tag expressions\n                const tagNameRegex = /'([^']+)'\\s*=\\s*'true'/g;\n                let tagMatch;\n                while((tagMatch = tagNameRegex.exec(tagsText)) !== null){\n                    tags.push(tagMatch[1]);\n                }\n            }\n            columns.push({\n                id: (0,uuid__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(),\n                name,\n                dataType,\n                isPrimaryKey,\n                isForeignKey: false,\n                isNullable,\n                comment,\n                tags\n            });\n        }\n        return columns;\n    }\n    /**\n   * Parse a foreign key constraint and create relationships\n   */ parseForeignKeyConstraint(statement) {\n        // Extract source table name (may be fully qualified)\n        const tableMatch = statement.match(/ALTER\\s+TABLE\\s+(?:\"([^\"]+(?:\\.[^\"]+)*?)\"|([a-zA-Z0-9_]+(?:\\.[a-zA-Z0-9_]+)*))/i);\n        if (!tableMatch) return;\n        // Get the full name and extract just the table part for lookup\n        const fullSourceName = tableMatch[1] || tableMatch[2];\n        const sourceParts = fullSourceName.split(\".\");\n        const tableName = sourceParts[sourceParts.length - 1].toUpperCase();\n        // Extract source columns\n        const sourceColsMatch = statement.match(/FOREIGN\\s+KEY\\s*\\(([^)]+)\\)/i);\n        if (!sourceColsMatch) return;\n        const sourceCols = sourceColsMatch[1].split(\",\").map((col)=>col.trim().replace(/\"/g, \"\").toUpperCase());\n        // Extract target table and columns\n        const refsMatch = statement.match(/REFERENCES\\s+(?:\"([^\"]+(?:\\.[^\"]+)*?)\"|([a-zA-Z0-9_]+(?:\\.[a-zA-Z0-9_]+)*))\\s*\\(([^)]+)\\)/i);\n        if (!refsMatch) return;\n        // Get the full target name and extract just the table part for lookup\n        const fullTargetName = refsMatch[1] || refsMatch[2];\n        const targetParts = fullTargetName.split(\".\");\n        const targetTable = targetParts[targetParts.length - 1].toUpperCase();\n        const targetCols = refsMatch[3].split(\",\").map((col)=>col.trim().replace(/\"/g, \"\").toUpperCase());\n        // Find matching source and target nodes\n        let sourceNode = null;\n        let targetNode = null;\n        let sourceId = \"\";\n        let targetId = \"\";\n        // First try exact match using the tableNames map\n        if (this.tableNames.has(tableName) && this.tableNames.has(targetTable)) {\n            sourceId = this.tableNames.get(tableName);\n            targetId = this.tableNames.get(targetTable);\n            sourceNode = this.nodes.find((node)=>node.id === sourceId);\n            targetNode = this.nodes.find((node)=>node.id === targetId);\n        }\n        // If that fails, try matching by label (which may include full paths)\n        if (!sourceNode || !targetNode) {\n            for (const node of this.nodes){\n                if (node.type === \"table\") {\n                    const nodeLabel = node.data.label.toUpperCase();\n                    // Check if node label matches full source name\n                    if (!sourceNode && (nodeLabel === fullSourceName.toUpperCase() || nodeLabel.endsWith(\".\" + tableName))) {\n                        sourceNode = node;\n                        sourceId = node.id;\n                    }\n                    // Check if node label matches full target name\n                    if (!targetNode && (nodeLabel === fullTargetName.toUpperCase() || nodeLabel.endsWith(\".\" + targetTable))) {\n                        targetNode = node;\n                        targetId = node.id;\n                    }\n                }\n            }\n        }\n        // If we have both source and target nodes\n        if (sourceNode && targetNode && sourceNode.type === \"table\" && targetNode.type === \"table\") {\n            // Update source columns to mark them as foreign keys\n            for(let i = 0; i < sourceCols.length && i < targetCols.length; i++){\n                const columnName = sourceCols[i];\n                const column = sourceNode.data.columns.find((col)=>col.name.toUpperCase() === columnName);\n                if (column) {\n                    column.isForeignKey = true;\n                    column.referencedTable = targetNode.data.label; // Use full label\n                    column.referencedColumn = targetCols[i];\n                }\n            }\n            // Create an edge between the tables\n            const edge = {\n                id: \"e\".concat(sourceId, \"-\").concat(targetId, \"-\").concat((0,uuid__WEBPACK_IMPORTED_MODULE_0__[\"default\"])()),\n                source: sourceId,\n                target: targetId,\n                sourceHandle: \"\",\n                targetHandle: \"\",\n                type: \"relationship\",\n                data: {\n                    relationshipType: \"one-to-many\"\n                }\n            };\n            this.edges.push(edge);\n        } else {\n            console.warn(\"Could not create relationship between \".concat(fullSourceName, \" and \").concat(fullTargetName, \" - tables not found\"));\n        }\n    }\n    constructor(ddl){\n        this.nodes = [];\n        this.edges = [];\n        this.tableNames = new Map() // Maps normalized table name to table ID\n        ;\n        this.ddl = ddl;\n    }\n}\n\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL2FwcC91dGlscy9ERExQYXJzZXIudHMiLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBb0M7QUFHckIsTUFBTUU7SUFVbkI7OztHQUdDLEdBQ0QsUUFBd0Q7UUFDdEQseUNBQXlDO1FBQ3pDLE1BQU1FLGFBQWEsSUFBSSxDQUFDQyxlQUFlLENBQUMsSUFBSSxDQUFDQyxHQUFHO1FBRWhEQyxRQUFRQyxHQUFHLENBQUMsV0FBNkIsT0FBbEJKLFdBQVdLLE1BQU0sRUFBQztRQUV6QyxxQ0FBcUM7UUFDckMsS0FBSyxNQUFNQyxhQUFhTixXQUFZO1lBQ2xDLElBQUksSUFBSSxDQUFDTyxzQkFBc0IsQ0FBQ0QsWUFBWTtnQkFDMUMsSUFBSSxDQUFDRSxnQkFBZ0IsQ0FBQ0Y7WUFDeEI7UUFDRjtRQUVBLGdEQUFnRDtRQUNoRCxLQUFLLE1BQU1BLGFBQWFOLFdBQVk7WUFDbEMsSUFBSSxJQUFJLENBQUNTLHlCQUF5QixDQUFDSCxZQUFZO2dCQUM3QyxJQUFJLENBQUNJLHlCQUF5QixDQUFDSjtZQUNqQztRQUNGO1FBRUFILFFBQVFDLEdBQUcsQ0FBQyxXQUEyQyxPQUFoQyxJQUFJLENBQUNPLEtBQUssQ0FBQ04sTUFBTSxFQUFDLGdCQUFnQyxPQUFsQixJQUFJLENBQUNPLEtBQUssQ0FBQ1AsTUFBTSxFQUFDO1FBQ3pFLE9BQU87WUFBRU0sT0FBTyxJQUFJLENBQUNBLEtBQUs7WUFBRUMsT0FBTyxJQUFJLENBQUNBLEtBQUs7UUFBQztJQUNoRDtJQUVBOzs7O0dBSUMsR0FDRCxnQkFBd0JWLEdBQVcsRUFBWTtRQUM3QywyREFBMkQ7UUFDM0QsTUFBTUYsYUFBdUIsRUFBRTtRQUMvQixJQUFJYSxtQkFBbUI7UUFDdkIsSUFBSUMsVUFBVTtRQUNkLElBQUlDLFlBQVk7UUFDaEIsSUFBSUMsWUFBWTtRQUVoQixJQUFLLElBQUlDLElBQUksR0FBR0EsSUFBSWYsSUFBSUcsTUFBTSxFQUFFWSxJQUFLO1lBQ25DLE1BQU1DLE9BQU9oQixHQUFHLENBQUNlLEVBQUU7WUFDbkIsTUFBTUUsV0FBV0YsSUFBSWYsSUFBSUcsTUFBTSxHQUFHLElBQUlILEdBQUcsQ0FBQ2UsSUFBSSxFQUFFLEdBQUc7WUFFbkQsdUJBQXVCO1lBQ3ZCLElBQUksQ0FBQ0gsV0FBV0ksU0FBUyxPQUFPQyxhQUFhLEtBQUs7Z0JBQ2hESCxZQUFZO1lBQ2Q7WUFFQSxrQ0FBa0M7WUFDbEMsSUFBSUEsYUFBY0UsQ0FBQUEsU0FBUyxRQUFRQSxTQUFTLElBQUcsR0FBSTtnQkFDakRGLFlBQVk7WUFDZDtZQUVBLDREQUE0RDtZQUM1RCxJQUFJQSxXQUFXO2dCQUNiSCxvQkFBb0JLO2dCQUNwQjtZQUNGO1lBRUEsZ0JBQWdCO1lBQ2hCLElBQUksQ0FBQ0EsU0FBUyxPQUFPQSxTQUFTLEdBQUUsS0FBT0QsQ0FBQUEsTUFBTSxLQUFLZixHQUFHLENBQUNlLElBQUUsRUFBRSxLQUFLLElBQUcsR0FBSTtnQkFDcEUsSUFBSSxDQUFDSCxTQUFTO29CQUNaQSxVQUFVO29CQUNWQyxZQUFZRztnQkFDZCxPQUFPLElBQUlBLFNBQVNILFdBQVc7b0JBQzdCRCxVQUFVO2dCQUNaO1lBQ0Y7WUFFQSxvQkFBb0I7WUFDcEIsSUFBSUksU0FBUyxPQUFPLENBQUNKLFNBQVM7Z0JBQzVCLElBQUlELGlCQUFpQk8sSUFBSSxJQUFJO29CQUMzQnBCLFdBQVdxQixJQUFJLENBQUNSLGlCQUFpQk8sSUFBSTtnQkFDdkM7Z0JBQ0FQLG1CQUFtQjtZQUNyQixPQUFPO2dCQUNMQSxvQkFBb0JLO1lBQ3RCO1FBQ0Y7UUFFQSwwREFBMEQ7UUFDMUQsSUFBSUwsaUJBQWlCTyxJQUFJLElBQUk7WUFDM0JwQixXQUFXcUIsSUFBSSxDQUFDUixpQkFBaUJPLElBQUk7UUFDdkM7UUFFQSxrQ0FBa0M7UUFDbEMsT0FBT3BCLFdBQVdzQixNQUFNLENBQUNDLENBQUFBLE9BQVFBLEtBQUtILElBQUksR0FBR2YsTUFBTSxHQUFHO0lBQ3hEO0lBRUE7O0dBRUMsR0FDRCx1QkFBK0JDLFNBQWlCLEVBQVc7UUFDekQsT0FBTyw0RkFBNEZrQixJQUFJLENBQUNsQjtJQUMxRztJQUVBOztHQUVDLEdBQ0QsMEJBQWtDQSxTQUFpQixFQUFXO1FBQzVELE9BQU8sNERBQTREa0IsSUFBSSxDQUFDbEI7SUFDMUU7SUFFQTs7R0FFQyxHQUNELGlCQUF5QkEsU0FBaUIsRUFBUTtZQUc5Qm1CO1FBRmxCLHlDQUF5QztRQUN6QyxNQUFNQSxZQUFZbkIsVUFBVW9CLEtBQUssQ0FBQztRQUNsQyxNQUFNQyxZQUFZRixDQUFBQSxzQkFBQUEsaUNBQUFBLGNBQUFBLFNBQVcsQ0FBQyxFQUFFLGNBQWRBLGtDQUFBQSxZQUFnQkcsV0FBVyxPQUFNO1FBRW5ELDJGQUEyRjtRQUMzRiwwRUFBMEU7UUFDMUUsTUFBTUMscUJBQXFCO1FBRTNCLE1BQU1DLFlBQVl4QixVQUFVb0IsS0FBSyxDQUFDRztRQUVsQyxJQUFJLENBQUNDLFdBQVc7UUFFaEIsb0VBQW9FO1FBQ3BFLElBQUlDLGdCQUFnQjtRQUNwQixJQUFJQyxZQUFZO1FBRWhCLGlFQUFpRTtRQUNqRSxJQUFJRixTQUFTLENBQUMsRUFBRSxFQUFFO1lBQ2hCQyxnQkFBZ0JELFNBQVMsQ0FBQyxFQUFFO1lBQzVCLE1BQU1HLFFBQVFGLGNBQWNHLEtBQUssQ0FBQztZQUNsQ0YsWUFBWUMsS0FBSyxDQUFDQSxNQUFNNUIsTUFBTSxHQUFHLEVBQUU7UUFDckMsT0FFSyxJQUFJeUIsU0FBUyxDQUFDLEdBQUcsRUFBRTtZQUN0QkMsZ0JBQWdCRCxTQUFTLENBQUMsR0FBRztZQUM3QixNQUFNRyxRQUFRRixjQUFjRyxLQUFLLENBQUM7WUFDbENGLFlBQVlDLEtBQUssQ0FBQ0EsTUFBTTVCLE1BQU0sR0FBRyxFQUFFO1FBQ3JDLE9BRUs7WUFDSCxNQUFNOEIsU0FBU0wsU0FBUyxDQUFDLEVBQUUsSUFBSUEsU0FBUyxDQUFDLEVBQUUsSUFBSTtZQUMvQyxNQUFNTSxhQUFhTixTQUFTLENBQUMsRUFBRSxJQUFJQSxTQUFTLENBQUMsRUFBRSxJQUFJO1lBQ25ELE1BQU1PLGdCQUFnQlAsU0FBUyxDQUFDLEVBQUUsSUFBSUEsU0FBUyxDQUFDLEVBQUUsSUFBSTtZQUV0RCxJQUFJTyxlQUFlO2dCQUNqQiw2Q0FBNkM7Z0JBQzdDTCxZQUFZSztnQkFDWk4sZ0JBQWdCLEdBQWFLLE9BQVZELFFBQU8sS0FBaUJILE9BQWRJLFlBQVcsS0FBYSxPQUFWSjtZQUM3QyxPQUFPLElBQUlJLFlBQVk7Z0JBQ3JCLHdDQUF3QztnQkFDeENKLFlBQVlJO2dCQUNaTCxnQkFBZ0IsR0FBYUMsT0FBVkcsUUFBTyxLQUFhLE9BQVZIO1lBQy9CLE9BQU87Z0JBQ0wsNEJBQTRCO2dCQUM1QkEsWUFBWUc7Z0JBQ1pKLGdCQUFnQkM7WUFDbEI7UUFDRjtRQUVBLElBQUksQ0FBQ0EsV0FBVztRQUVoQixzRkFBc0Y7UUFDdEYsTUFBTU0sc0JBQXNCTixVQUFVSixXQUFXO1FBRWpELHFDQUFxQztRQUNyQyxNQUFNVyxpQkFBaUIsSUFBSSxDQUFDQyx3QkFBd0IsQ0FBQ2xDO1FBQ3JELE1BQU1tQyxVQUFVLElBQUksQ0FBQ0MsWUFBWSxDQUFDSCxnQkFBZ0JqQztRQUVsRCxtQ0FBbUM7UUFDbkMsTUFBTXFDLGVBQWVyQyxVQUFVb0IsS0FBSyxDQUFDO1FBQ3JDLE1BQU1rQixVQUFVRCxlQUFlQSxZQUFZLENBQUMsRUFBRSxDQUFDRSxPQUFPLENBQUMsTUFBTSxPQUFPO1FBRXBFLDBCQUEwQjtRQUMxQixNQUFNQyxZQUFZeEMsVUFBVW9CLEtBQUssQ0FBQztRQUNsQyxJQUFJcUIsT0FBaUIsRUFBRTtRQUV2QixJQUFJRCxXQUFXO1lBQ2IsTUFBTUUsV0FBV0YsU0FBUyxDQUFDLEVBQUU7WUFDN0IsOERBQThEO1lBQzlELE1BQU1HLFdBQVc7WUFDakIsSUFBSUM7WUFDSixNQUFPLENBQUNBLFdBQVdELFNBQVNFLElBQUksQ0FBQ0gsU0FBUSxNQUFPLEtBQU07Z0JBQ3BERCxLQUFLMUIsSUFBSSxDQUFDNkIsUUFBUSxDQUFDLEVBQUU7WUFDdkI7UUFDRjtRQUVBLGtCQUFrQjtRQUNsQixNQUFNRSxTQUFTLFNBQWtCLE9BQVR2RCxnREFBTUE7UUFDOUIsSUFBSSxDQUFDd0QsVUFBVSxDQUFDQyxHQUFHLENBQUNoQixxQkFBcUJjO1FBRXpDLE1BQU1HLE9BQWdCO1lBQ3BCQyxJQUFJSjtZQUNKSyxNQUFNO1lBQ05DLFVBQVU7Z0JBQ1JDLEdBQUdDLEtBQUtDLEtBQUssQ0FBQ0QsS0FBS0UsTUFBTSxLQUFLO2dCQUM5QkMsR0FBR0gsS0FBS0MsS0FBSyxDQUFDRCxLQUFLRSxNQUFNLEtBQUs7WUFDaEM7WUFDQUUsTUFBTTtnQkFDSkMsT0FBT2xDO2dCQUNQVTtnQkFDQWQsV0FBV0E7Z0JBQ1hpQjtnQkFDQUc7WUFDRjtRQUNGO1FBRUEsSUFBSSxDQUFDcEMsS0FBSyxDQUFDVSxJQUFJLENBQUNrQztJQUNsQjtJQUVBOztHQUVDLEdBQ0QseUJBQWlDakQsU0FBaUIsRUFBVTtRQUMxRCxxREFBcUQ7UUFDckQsTUFBTTRELFdBQVc1RCxVQUFVNkQsT0FBTyxDQUFDO1FBQ25DLElBQUlELGFBQWEsQ0FBQyxHQUFHLE9BQU87UUFFNUIsSUFBSUUsUUFBUTtRQUNaLElBQUlDLFNBQVNILFdBQVc7UUFFeEIsSUFBSyxJQUFJakQsSUFBSWlELFdBQVcsR0FBR2pELElBQUlYLFVBQVVELE1BQU0sRUFBRVksSUFBSztZQUNwRCxJQUFJWCxTQUFTLENBQUNXLEVBQUUsS0FBSyxLQUFLbUQ7aUJBQ3JCLElBQUk5RCxTQUFTLENBQUNXLEVBQUUsS0FBSyxLQUFLbUQ7WUFFL0IsSUFBSUEsVUFBVSxHQUFHO2dCQUNmQyxTQUFTcEQ7Z0JBQ1Q7WUFDRjtRQUNGO1FBRUEsT0FBT1gsVUFBVWdFLFNBQVMsQ0FBQ0osV0FBVyxHQUFHRyxRQUFRakQsSUFBSTtJQUN2RDtJQUVBOztHQUVDLEdBQ0QsYUFBcUJtQixjQUFzQixFQUFFZ0MsYUFBcUIsRUFBWTtRQUM1RSxNQUFNOUIsVUFBb0IsRUFBRTtRQUM1QixNQUFNK0IsUUFBUWpDLGVBQWVMLEtBQUssQ0FBQyxPQUFPdUMsR0FBRyxDQUFDQyxDQUFBQSxPQUFRQSxLQUFLdEQsSUFBSTtRQUUvRCxJQUFJdUQsb0JBQThCLEVBQUU7UUFFcEMsNENBQTRDO1FBQzVDLE1BQU1DLGtCQUFrQnJDLGVBQWViLEtBQUssQ0FBQztRQUM3QyxJQUFJa0QsaUJBQWlCO1lBQ25CRCxvQkFBb0JDLGVBQWUsQ0FBQyxFQUFFLENBQ25DMUMsS0FBSyxDQUFDLEtBQ051QyxHQUFHLENBQUNJLENBQUFBLE1BQU9BLElBQUl6RCxJQUFJLEdBQUd5QixPQUFPLENBQUMsTUFBTSxJQUFJakIsV0FBVztRQUN4RDtRQUVBLGlDQUFpQztRQUNqQyxLQUFLLE1BQU04QyxRQUFRRixNQUFPO1lBQ3hCLDBDQUEwQztZQUMxQyxJQUFJLG1DQUFtQ2hELElBQUksQ0FBQ2tELE9BQU87WUFFbkQsc0JBQXNCO1lBQ3RCLE1BQU01QyxZQUFZNEMsS0FBS2hELEtBQUssQ0FBQztZQUM3QixJQUFJLENBQUNJLFdBQVc7WUFFaEIsTUFBTWdELE9BQU9oRCxTQUFTLENBQUMsRUFBRSxJQUFJQSxTQUFTLENBQUMsRUFBRTtZQUV6QyxvQkFBb0I7WUFDcEIsTUFBTUwsWUFBWWlELEtBQUtoRCxLQUFLLENBQUM7WUFDN0IsTUFBTXFELFdBQVd0RCxZQUFZQSxTQUFTLENBQUMsRUFBRSxHQUFHO1lBRTVDLDhCQUE4QjtZQUM5QixNQUFNdUQsYUFBYSxDQUFDLGNBQWN4RCxJQUFJLENBQUNrRDtZQUV2QyxtQ0FBbUM7WUFDbkMsTUFBTU8sZUFBZU4sa0JBQWtCTyxRQUFRLENBQUNKLEtBQUtsRCxXQUFXO1lBRWhFLDZCQUE2QjtZQUM3QixNQUFNZSxlQUFlK0IsS0FBS2hELEtBQUssQ0FBQztZQUNoQyxNQUFNa0IsVUFBVUQsZUFBZUEsWUFBWSxDQUFDLEVBQUUsQ0FBQ0UsT0FBTyxDQUFDLE1BQU0sT0FBTztZQUVwRSw4Q0FBOEM7WUFDOUMsSUFBSUUsT0FBaUIsRUFBRTtZQUN2QixNQUFNRSxXQUFXLElBQUlrQyxPQUFPLDJDQUFvREwsT0FBVEEsTUFBSyxNQUFTLE9BQUxBLE1BQUssK0JBQTZCO1lBQ2xILE1BQU1oQyxZQUFZeUIsY0FBYzdDLEtBQUssQ0FBQ3VCO1lBRXRDLElBQUlILFdBQVc7Z0JBQ2IsTUFBTUUsV0FBV0YsU0FBUyxDQUFDLEVBQUU7Z0JBQzdCLHlDQUF5QztnQkFDekMsTUFBTXNDLGVBQWU7Z0JBQ3JCLElBQUlsQztnQkFDSixNQUFPLENBQUNBLFdBQVdrQyxhQUFhakMsSUFBSSxDQUFDSCxTQUFRLE1BQU8sS0FBTTtvQkFDeERELEtBQUsxQixJQUFJLENBQUM2QixRQUFRLENBQUMsRUFBRTtnQkFDdkI7WUFDRjtZQUVBVCxRQUFRcEIsSUFBSSxDQUFDO2dCQUNYbUMsSUFBSTNELGdEQUFNQTtnQkFDVmlGO2dCQUNBQztnQkFDQUU7Z0JBQ0FJLGNBQWM7Z0JBQ2RMO2dCQUNBcEM7Z0JBQ0FHO1lBQ0Y7UUFDRjtRQUVBLE9BQU9OO0lBQ1Q7SUFFQTs7R0FFQyxHQUNELDBCQUFrQ25DLFNBQWlCLEVBQVE7UUFDekQscURBQXFEO1FBQ3JELE1BQU1nRixhQUFhaEYsVUFBVW9CLEtBQUssQ0FBQztRQUNuQyxJQUFJLENBQUM0RCxZQUFZO1FBRWpCLCtEQUErRDtRQUMvRCxNQUFNQyxpQkFBa0JELFVBQVUsQ0FBQyxFQUFFLElBQUlBLFVBQVUsQ0FBQyxFQUFFO1FBQ3RELE1BQU1FLGNBQWNELGVBQWVyRCxLQUFLLENBQUM7UUFDekMsTUFBTUYsWUFBWXdELFdBQVcsQ0FBQ0EsWUFBWW5GLE1BQU0sR0FBRyxFQUFFLENBQUN1QixXQUFXO1FBRWpFLHlCQUF5QjtRQUN6QixNQUFNNkQsa0JBQWtCbkYsVUFBVW9CLEtBQUssQ0FBQztRQUN4QyxJQUFJLENBQUMrRCxpQkFBaUI7UUFFdEIsTUFBTUMsYUFBYUQsZUFBZSxDQUFDLEVBQUUsQ0FDbEN2RCxLQUFLLENBQUMsS0FDTnVDLEdBQUcsQ0FBQ0ksQ0FBQUEsTUFBT0EsSUFBSXpELElBQUksR0FBR3lCLE9BQU8sQ0FBQyxNQUFNLElBQUlqQixXQUFXO1FBRXRELG1DQUFtQztRQUNuQyxNQUFNK0QsWUFBWXJGLFVBQVVvQixLQUFLLENBQUM7UUFDbEMsSUFBSSxDQUFDaUUsV0FBVztRQUVoQixzRUFBc0U7UUFDdEUsTUFBTUMsaUJBQWtCRCxTQUFTLENBQUMsRUFBRSxJQUFJQSxTQUFTLENBQUMsRUFBRTtRQUNwRCxNQUFNRSxjQUFjRCxlQUFlMUQsS0FBSyxDQUFDO1FBQ3pDLE1BQU00RCxjQUFjRCxXQUFXLENBQUNBLFlBQVl4RixNQUFNLEdBQUcsRUFBRSxDQUFDdUIsV0FBVztRQUVuRSxNQUFNbUUsYUFBYUosU0FBUyxDQUFDLEVBQUUsQ0FDNUJ6RCxLQUFLLENBQUMsS0FDTnVDLEdBQUcsQ0FBQ0ksQ0FBQUEsTUFBT0EsSUFBSXpELElBQUksR0FBR3lCLE9BQU8sQ0FBQyxNQUFNLElBQUlqQixXQUFXO1FBRXRELHdDQUF3QztRQUN4QyxJQUFJb0UsYUFBYTtRQUNqQixJQUFJQyxhQUFhO1FBQ2pCLElBQUlDLFdBQVc7UUFDZixJQUFJQyxXQUFXO1FBRWYsaURBQWlEO1FBQ2pELElBQUksSUFBSSxDQUFDOUMsVUFBVSxDQUFDK0MsR0FBRyxDQUFDcEUsY0FBYyxJQUFJLENBQUNxQixVQUFVLENBQUMrQyxHQUFHLENBQUNOLGNBQWM7WUFDdEVJLFdBQVcsSUFBSSxDQUFDN0MsVUFBVSxDQUFDZ0QsR0FBRyxDQUFDckU7WUFDL0JtRSxXQUFXLElBQUksQ0FBQzlDLFVBQVUsQ0FBQ2dELEdBQUcsQ0FBQ1A7WUFDL0JFLGFBQWEsSUFBSSxDQUFDckYsS0FBSyxDQUFDMkYsSUFBSSxDQUFDL0MsQ0FBQUEsT0FBUUEsS0FBS0MsRUFBRSxLQUFLMEM7WUFDakRELGFBQWEsSUFBSSxDQUFDdEYsS0FBSyxDQUFDMkYsSUFBSSxDQUFDL0MsQ0FBQUEsT0FBUUEsS0FBS0MsRUFBRSxLQUFLMkM7UUFDbkQ7UUFFQSxzRUFBc0U7UUFDdEUsSUFBSSxDQUFDSCxjQUFjLENBQUNDLFlBQVk7WUFDOUIsS0FBSyxNQUFNMUMsUUFBUSxJQUFJLENBQUM1QyxLQUFLLENBQUU7Z0JBQzdCLElBQUk0QyxLQUFLRSxJQUFJLEtBQUssU0FBUztvQkFDekIsTUFBTThDLFlBQVloRCxLQUFLUyxJQUFJLENBQUNDLEtBQUssQ0FBQ3JDLFdBQVc7b0JBRTdDLCtDQUErQztvQkFDL0MsSUFBSSxDQUFDb0UsY0FBZU8sQ0FBQUEsY0FBY2hCLGVBQWUzRCxXQUFXLE1BQ3hEMkUsVUFBVUMsUUFBUSxDQUFDLE1BQU14RSxVQUFTLEdBQUk7d0JBQ3hDZ0UsYUFBYXpDO3dCQUNiMkMsV0FBVzNDLEtBQUtDLEVBQUU7b0JBQ3BCO29CQUVBLCtDQUErQztvQkFDL0MsSUFBSSxDQUFDeUMsY0FBZU0sQ0FBQUEsY0FBY1gsZUFBZWhFLFdBQVcsTUFDeEQyRSxVQUFVQyxRQUFRLENBQUMsTUFBTVYsWUFBVyxHQUFJO3dCQUMxQ0csYUFBYTFDO3dCQUNiNEMsV0FBVzVDLEtBQUtDLEVBQUU7b0JBQ3BCO2dCQUNGO1lBQ0Y7UUFDRjtRQUVBLDBDQUEwQztRQUMxQyxJQUFJd0MsY0FBY0MsY0FBY0QsV0FBV3ZDLElBQUksS0FBSyxXQUFXd0MsV0FBV3hDLElBQUksS0FBSyxTQUFTO1lBQzFGLHFEQUFxRDtZQUNyRCxJQUFLLElBQUl4QyxJQUFJLEdBQUdBLElBQUl5RSxXQUFXckYsTUFBTSxJQUFJWSxJQUFJOEUsV0FBVzFGLE1BQU0sRUFBRVksSUFBSztnQkFDbkUsTUFBTXdGLGFBQWFmLFVBQVUsQ0FBQ3pFLEVBQUU7Z0JBQ2hDLE1BQU15RixTQUFTVixXQUFXaEMsSUFBSSxDQUFDdkIsT0FBTyxDQUFDNkQsSUFBSSxDQUN6QyxDQUFDekIsTUFBZ0JBLElBQUlDLElBQUksQ0FBQ2xELFdBQVcsT0FBTzZFO2dCQUc5QyxJQUFJQyxRQUFRO29CQUNWQSxPQUFPckIsWUFBWSxHQUFHO29CQUN0QnFCLE9BQU9DLGVBQWUsR0FBR1YsV0FBV2pDLElBQUksQ0FBQ0MsS0FBSyxFQUFFLGlCQUFpQjtvQkFDakV5QyxPQUFPRSxnQkFBZ0IsR0FBR2IsVUFBVSxDQUFDOUUsRUFBRTtnQkFDekM7WUFDRjtZQUVBLG9DQUFvQztZQUNwQyxNQUFNNEYsT0FBaUI7Z0JBQ3JCckQsSUFBSSxJQUFnQjJDLE9BQVpELFVBQVMsS0FBZXJHLE9BQVpzRyxVQUFTLEtBQVksT0FBVHRHLGdEQUFNQTtnQkFDdENpSCxRQUFRWjtnQkFDUmEsUUFBUVo7Z0JBQ1JhLGNBQWM7Z0JBQ2RDLGNBQWM7Z0JBQ2R4RCxNQUFNO2dCQUNOTyxNQUFNO29CQUFFa0Qsa0JBQWtCO2dCQUFjO1lBQzFDO1lBRUEsSUFBSSxDQUFDdEcsS0FBSyxDQUFDUyxJQUFJLENBQUN3RjtRQUNsQixPQUFPO1lBQ0wxRyxRQUFRZ0gsSUFBSSxDQUFDLHlDQUErRHZCLE9BQXRCTCxnQkFBZSxTQUFzQixPQUFmSyxnQkFBZTtRQUM3RjtJQUNGO0lBMVpBd0IsWUFBWWxILEdBQVcsQ0FBRTthQUpqQlMsUUFBbUIsRUFBRTthQUNyQkMsUUFBb0IsRUFBRTthQUN0QnlDLGFBQWtDLElBQUlnRSxNQUFPLHlDQUF5Qzs7UUFHNUYsSUFBSSxDQUFDbkgsR0FBRyxHQUFHQTtJQUNiO0FBeVpGO0FBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vYXBwL3V0aWxzL0RETFBhcnNlci50cz8xOGFmIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IHY0IGFzIHV1aWR2NCB9IGZyb20gJ3V1aWQnO1xuaW1wb3J0IHsgRVJETm9kZSwgRWRnZVR5cGUsIENvbHVtbiB9IGZyb20gJy4vdHlwZXMnO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBERExQYXJzZXIge1xuICBwcml2YXRlIGRkbDogc3RyaW5nO1xuICBwcml2YXRlIG5vZGVzOiBFUkROb2RlW10gPSBbXTtcbiAgcHJpdmF0ZSBlZGdlczogRWRnZVR5cGVbXSA9IFtdO1xuICBwcml2YXRlIHRhYmxlTmFtZXM6IE1hcDxzdHJpbmcsIHN0cmluZz4gPSBuZXcgTWFwKCk7IC8vIE1hcHMgbm9ybWFsaXplZCB0YWJsZSBuYW1lIHRvIHRhYmxlIElEXG5cbiAgY29uc3RydWN0b3IoZGRsOiBzdHJpbmcpIHtcbiAgICB0aGlzLmRkbCA9IGRkbDtcbiAgfVxuXG4gIC8qKlxuICAgKiBNYWluIG1ldGhvZCB0byBwYXJzZSBEREwgYW5kIGdlbmVyYXRlIG5vZGVzIGFuZCBlZGdlc1xuICAgKiBAcmV0dXJucyBPYmplY3QgY29udGFpbmluZyBub2RlcyBhbmQgZWRnZXNcbiAgICovXG4gIHB1YmxpYyBwYXJzZSgpOiB7IG5vZGVzOiBFUkROb2RlW10sIGVkZ2VzOiBFZGdlVHlwZVtdIH0ge1xuICAgIC8vIFNwbGl0IHRoZSBEREwgaW50byBzZXBhcmF0ZSBzdGF0ZW1lbnRzXG4gICAgY29uc3Qgc3RhdGVtZW50cyA9IHRoaXMuc3BsaXRTdGF0ZW1lbnRzKHRoaXMuZGRsKTtcbiAgICBcbiAgICBjb25zb2xlLmxvZyhgUGFyc2luZyAke3N0YXRlbWVudHMubGVuZ3RofSBTUUwgc3RhdGVtZW50c2ApO1xuICAgIFxuICAgIC8vIEZpcnN0IHBhc3M6IENyZWF0ZSBhbGwgdGFibGUgbm9kZXNcbiAgICBmb3IgKGNvbnN0IHN0YXRlbWVudCBvZiBzdGF0ZW1lbnRzKSB7XG4gICAgICBpZiAodGhpcy5pc0NyZWF0ZVRhYmxlU3RhdGVtZW50KHN0YXRlbWVudCkpIHtcbiAgICAgICAgdGhpcy5wYXJzZUNyZWF0ZVRhYmxlKHN0YXRlbWVudCk7XG4gICAgICB9XG4gICAgfVxuICAgIFxuICAgIC8vIFNlY29uZCBwYXNzOiBIYW5kbGUgZm9yZWlnbiBrZXkgcmVsYXRpb25zaGlwc1xuICAgIGZvciAoY29uc3Qgc3RhdGVtZW50IG9mIHN0YXRlbWVudHMpIHtcbiAgICAgIGlmICh0aGlzLmlzQWx0ZXJUYWJsZUFkZEZvcmVpZ25LZXkoc3RhdGVtZW50KSkge1xuICAgICAgICB0aGlzLnBhcnNlRm9yZWlnbktleUNvbnN0cmFpbnQoc3RhdGVtZW50KTtcbiAgICAgIH1cbiAgICB9XG4gICAgXG4gICAgY29uc29sZS5sb2coYENyZWF0ZWQgJHt0aGlzLm5vZGVzLmxlbmd0aH0gdGFibGVzIGFuZCAke3RoaXMuZWRnZXMubGVuZ3RofSByZWxhdGlvbnNoaXBzYCk7XG4gICAgcmV0dXJuIHsgbm9kZXM6IHRoaXMubm9kZXMsIGVkZ2VzOiB0aGlzLmVkZ2VzIH07XG4gIH1cblxuICAvKipcbiAgICogU3BsaXQgRERMIGludG8gc2VwYXJhdGUgU1FMIHN0YXRlbWVudHNcbiAgICogSGFuZGxlcyBtdWx0aXBsZSBzdGF0ZW1lbnRzIHNlcGFyYXRlZCBieSBzZW1pY29sb25zLCBhY2NvdW50aW5nIGZvciBxdW90ZWQgdGV4dFxuICAgKiBhbmQgbmVzdGVkIHN0YXRlbWVudHMuXG4gICAqL1xuICBwcml2YXRlIHNwbGl0U3RhdGVtZW50cyhkZGw6IHN0cmluZyk6IHN0cmluZ1tdIHtcbiAgICAvLyBTcGxpdCBieSBzZW1pY29sb25zLCBidXQgaWdub3JlIHNlbWljb2xvbnMgaW5zaWRlIHF1b3Rlc1xuICAgIGNvbnN0IHN0YXRlbWVudHM6IHN0cmluZ1tdID0gW107XG4gICAgbGV0IGN1cnJlbnRTdGF0ZW1lbnQgPSAnJztcbiAgICBsZXQgaW5RdW90ZSA9IGZhbHNlO1xuICAgIGxldCBxdW90ZUNoYXIgPSAnJztcbiAgICBsZXQgaW5Db21tZW50ID0gZmFsc2U7XG4gICAgXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBkZGwubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IGNoYXIgPSBkZGxbaV07XG4gICAgICBjb25zdCBuZXh0Q2hhciA9IGkgPCBkZGwubGVuZ3RoIC0gMSA/IGRkbFtpICsgMV0gOiAnJztcbiAgICAgIFxuICAgICAgLy8gSGFuZGxlIGxpbmUgY29tbWVudHNcbiAgICAgIGlmICghaW5RdW90ZSAmJiBjaGFyID09PSAnLScgJiYgbmV4dENoYXIgPT09ICctJykge1xuICAgICAgICBpbkNvbW1lbnQgPSB0cnVlO1xuICAgICAgfVxuICAgICAgXG4gICAgICAvLyBFbmQgb2YgbGluZSB0ZXJtaW5hdGVzIGNvbW1lbnRzXG4gICAgICBpZiAoaW5Db21tZW50ICYmIChjaGFyID09PSAnXFxuJyB8fCBjaGFyID09PSAnXFxyJykpIHtcbiAgICAgICAgaW5Db21tZW50ID0gZmFsc2U7XG4gICAgICB9XG4gICAgICBcbiAgICAgIC8vIFNraXAgY29tbWVudCBjb250ZW50IGJ1dCBrZWVwIGFkZGluZyB0byBjdXJyZW50IHN0YXRlbWVudFxuICAgICAgaWYgKGluQ29tbWVudCkge1xuICAgICAgICBjdXJyZW50U3RhdGVtZW50ICs9IGNoYXI7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgXG4gICAgICAvLyBIYW5kbGUgcXVvdGVzXG4gICAgICBpZiAoKGNoYXIgPT09IFwiJ1wiIHx8IGNoYXIgPT09ICdcIicpICYmIChpID09PSAwIHx8IGRkbFtpLTFdICE9PSAnXFxcXCcpKSB7XG4gICAgICAgIGlmICghaW5RdW90ZSkge1xuICAgICAgICAgIGluUXVvdGUgPSB0cnVlO1xuICAgICAgICAgIHF1b3RlQ2hhciA9IGNoYXI7XG4gICAgICAgIH0gZWxzZSBpZiAoY2hhciA9PT0gcXVvdGVDaGFyKSB7XG4gICAgICAgICAgaW5RdW90ZSA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBcbiAgICAgIC8vIEhhbmRsZSBzZW1pY29sb25zXG4gICAgICBpZiAoY2hhciA9PT0gJzsnICYmICFpblF1b3RlKSB7XG4gICAgICAgIGlmIChjdXJyZW50U3RhdGVtZW50LnRyaW0oKSkge1xuICAgICAgICAgIHN0YXRlbWVudHMucHVzaChjdXJyZW50U3RhdGVtZW50LnRyaW0oKSk7XG4gICAgICAgIH1cbiAgICAgICAgY3VycmVudFN0YXRlbWVudCA9ICcnO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY3VycmVudFN0YXRlbWVudCArPSBjaGFyO1xuICAgICAgfVxuICAgIH1cbiAgICBcbiAgICAvLyBBZGQgdGhlIGxhc3Qgc3RhdGVtZW50IGlmIHRoZXJlJ3Mgbm8gdHJhaWxpbmcgc2VtaWNvbG9uXG4gICAgaWYgKGN1cnJlbnRTdGF0ZW1lbnQudHJpbSgpKSB7XG4gICAgICBzdGF0ZW1lbnRzLnB1c2goY3VycmVudFN0YXRlbWVudC50cmltKCkpO1xuICAgIH1cbiAgICBcbiAgICAvLyBGaWx0ZXIgb3V0IGFueSBlbXB0eSBzdGF0ZW1lbnRzXG4gICAgcmV0dXJuIHN0YXRlbWVudHMuZmlsdGVyKHN0bXQgPT4gc3RtdC50cmltKCkubGVuZ3RoID4gMCk7XG4gIH1cblxuICAvKipcbiAgICogQ2hlY2sgaWYgYSBzdGF0ZW1lbnQgaXMgYSBDUkVBVEUgVEFCTEUgc3RhdGVtZW50XG4gICAqL1xuICBwcml2YXRlIGlzQ3JlYXRlVGFibGVTdGF0ZW1lbnQoc3RhdGVtZW50OiBzdHJpbmcpOiBib29sZWFuIHtcbiAgICByZXR1cm4gL0NSRUFURVxccysoT1JcXHMrUkVQTEFDRVxccyspPyhUQUJMRXxWSUVXfE1BVEVSSUFMSVpFRF9WSUVXfERZTkFNSUNfVEFCTEV8SUNFQkVSR19UQUJMRSlcXHMrL2kudGVzdChzdGF0ZW1lbnQpO1xuICB9XG5cbiAgLyoqXG4gICAqIENoZWNrIGlmIGEgc3RhdGVtZW50IGlzIGFuIEFMVEVSIFRBQkxFIEFERCBGT1JFSUdOIEtFWSBzdGF0ZW1lbnRcbiAgICovXG4gIHByaXZhdGUgaXNBbHRlclRhYmxlQWRkRm9yZWlnbktleShzdGF0ZW1lbnQ6IHN0cmluZyk6IGJvb2xlYW4ge1xuICAgIHJldHVybiAvQUxURVJcXHMrVEFCTEUuKkFERFxccysoQ09OU1RSQUlOVFxccytcXHcrXFxzKyk/Rk9SRUlHTlxccytLRVkvaS50ZXN0KHN0YXRlbWVudCk7XG4gIH1cblxuICAvKipcbiAgICogUGFyc2UgYSBDUkVBVEUgVEFCTEUgc3RhdGVtZW50IGFuZCBhZGQgdG8gbm9kZXNcbiAgICovXG4gIHByaXZhdGUgcGFyc2VDcmVhdGVUYWJsZShzdGF0ZW1lbnQ6IHN0cmluZyk6IHZvaWQge1xuICAgIC8vIEV4dHJhY3QgdGFibGUgdHlwZSAoVEFCTEUsIFZJRVcsIGV0Yy4pXG4gICAgY29uc3QgdHlwZU1hdGNoID0gc3RhdGVtZW50Lm1hdGNoKC9DUkVBVEVcXHMrKE9SXFxzK1JFUExBQ0VcXHMrKT8oVEFCTEV8VklFV3xNQVRFUklBTElaRURfVklFV3xEWU5BTUlDX1RBQkxFfElDRUJFUkdfVEFCTEUpXFxzKy9pKTtcbiAgICBjb25zdCB0YWJsZVR5cGUgPSB0eXBlTWF0Y2g/LlsyXT8udG9VcHBlckNhc2UoKSB8fCAnVEFCTEUnO1xuICAgIFxuICAgIC8vIEV4dHJhY3QgZnVsbHkgcXVhbGlmaWVkIHRhYmxlIG5hbWUgLSBhbGxvdyBmb3IgcXVvdGVzIGFyb3VuZCBlYWNoIHBhcnQgb3IgdGhlIHdob2xlIG5hbWVcbiAgICAvLyBGb3JtYXQgY2FuIGJlOiBcIkRCXCIuXCJTQ0hFTUFcIi5cIlRBQkxFXCIgb3IgREIuU0NIRU1BLlRBQkxFIG9yIGNvbWJpbmF0aW9uc1xuICAgIGNvbnN0IHF1YWxpZmllZE5hbWVSZWdleCA9IC9DUkVBVEVcXHMrKE9SXFxzK1JFUExBQ0VcXHMrKT8oVEFCTEV8VklFV3xNQVRFUklBTElaRURfVklFV3xEWU5BTUlDX1RBQkxFfElDRUJFUkdfVEFCTEUpXFxzKyg/Oig/OlwiKFteXCJdKylcInwoW2EtekEtWjAtOV9dKykpKD86XFwuKD86XCIoW15cIl0rKVwifChbYS16QS1aMC05X10rKSkpPyg/OlxcLig/OlwiKFteXCJdKylcInwoW2EtekEtWjAtOV9dKykpKT98XCIoW15cIl0rXFwuW15cIl0rKD86XFwuW15cIl0rKT8pXCJ8KFthLXpBLVowLTlfXStcXC5bYS16QS1aMC05X10rKD86XFwuW2EtekEtWjAtOV9dKyk/KSkvaTtcbiAgICBcbiAgICBjb25zdCBuYW1lTWF0Y2ggPSBzdGF0ZW1lbnQubWF0Y2gocXVhbGlmaWVkTmFtZVJlZ2V4KTtcbiAgICBcbiAgICBpZiAoIW5hbWVNYXRjaCkgcmV0dXJuO1xuICAgIFxuICAgIC8vIEV4dHJhY3QgdGhlIHBhcnRzIG9mIHRoZSBxdWFsaWZpZWQgbmFtZSAoZGF0YWJhc2UsIHNjaGVtYSwgdGFibGUpXG4gICAgbGV0IGZ1bGxUYWJsZU5hbWUgPSAnJztcbiAgICBsZXQgdGFibGVOYW1lID0gJyc7XG4gICAgXG4gICAgLy8gQ2hlY2sgaWYgd2UgbWF0Y2hlZCBhIGZ1bGx5IHF1b3RlZCBuYW1lIGxpa2UgXCJEQi5TQ0hFTUEuVEFCTEVcIlxuICAgIGlmIChuYW1lTWF0Y2hbOV0pIHtcbiAgICAgIGZ1bGxUYWJsZU5hbWUgPSBuYW1lTWF0Y2hbOV07XG4gICAgICBjb25zdCBwYXJ0cyA9IGZ1bGxUYWJsZU5hbWUuc3BsaXQoJy4nKTtcbiAgICAgIHRhYmxlTmFtZSA9IHBhcnRzW3BhcnRzLmxlbmd0aCAtIDFdO1xuICAgIH0gXG4gICAgLy8gQ2hlY2sgaWYgd2UgbWF0Y2hlZCBhbiB1bnF1b3RlZCBmdWxseSBxdWFsaWZpZWQgbmFtZSBsaWtlIERCLlNDSEVNQS5UQUJMRVxuICAgIGVsc2UgaWYgKG5hbWVNYXRjaFsxMF0pIHtcbiAgICAgIGZ1bGxUYWJsZU5hbWUgPSBuYW1lTWF0Y2hbMTBdO1xuICAgICAgY29uc3QgcGFydHMgPSBmdWxsVGFibGVOYW1lLnNwbGl0KCcuJyk7XG4gICAgICB0YWJsZU5hbWUgPSBwYXJ0c1twYXJ0cy5sZW5ndGggLSAxXTtcbiAgICB9XG4gICAgLy8gT3RoZXJ3aXNlLCBidWlsZCBmcm9tIHRoZSBpbmRpdmlkdWFsIHBhcnRzXG4gICAgZWxzZSB7XG4gICAgICBjb25zdCBkYlBhcnQgPSBuYW1lTWF0Y2hbM10gfHwgbmFtZU1hdGNoWzRdIHx8ICcnO1xuICAgICAgY29uc3Qgc2NoZW1hUGFydCA9IG5hbWVNYXRjaFs1XSB8fCBuYW1lTWF0Y2hbNl0gfHwgJyc7XG4gICAgICBjb25zdCB0YWJsZU5hbWVQYXJ0ID0gbmFtZU1hdGNoWzddIHx8IG5hbWVNYXRjaFs4XSB8fCAnJztcbiAgICAgIFxuICAgICAgaWYgKHRhYmxlTmFtZVBhcnQpIHtcbiAgICAgICAgLy8gV2UgaGF2ZSBhIHRocmVlLXBhcnQgbmFtZTogREIuU0NIRU1BLlRBQkxFXG4gICAgICAgIHRhYmxlTmFtZSA9IHRhYmxlTmFtZVBhcnQ7XG4gICAgICAgIGZ1bGxUYWJsZU5hbWUgPSBgJHtkYlBhcnR9LiR7c2NoZW1hUGFydH0uJHt0YWJsZU5hbWV9YDtcbiAgICAgIH0gZWxzZSBpZiAoc2NoZW1hUGFydCkge1xuICAgICAgICAvLyBXZSBoYXZlIGEgdHdvLXBhcnQgbmFtZTogU0NIRU1BLlRBQkxFXG4gICAgICAgIHRhYmxlTmFtZSA9IHNjaGVtYVBhcnQ7XG4gICAgICAgIGZ1bGxUYWJsZU5hbWUgPSBgJHtkYlBhcnR9LiR7dGFibGVOYW1lfWA7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBXZSBoYXZlIGp1c3QgYSB0YWJsZSBuYW1lXG4gICAgICAgIHRhYmxlTmFtZSA9IGRiUGFydDtcbiAgICAgICAgZnVsbFRhYmxlTmFtZSA9IHRhYmxlTmFtZTtcbiAgICAgIH1cbiAgICB9XG4gICAgXG4gICAgaWYgKCF0YWJsZU5hbWUpIHJldHVybjtcbiAgICBcbiAgICAvLyBVc2UgdGhlIGZ1bGwgbmFtZSBmb3IgZGlzcGxheSBidXQga2VlcCB0aGUgc2ltcGxlIHRhYmxlIG5hbWUgZm9yIGludGVybmFsIHJlZmVyZW5jZVxuICAgIGNvbnN0IG5vcm1hbGl6ZWRUYWJsZU5hbWUgPSB0YWJsZU5hbWUudG9VcHBlckNhc2UoKTtcbiAgICBcbiAgICAvLyBFeHRyYWN0IGNvbHVtbnMgZnJvbSB0aGUgc3RhdGVtZW50XG4gICAgY29uc3QgY29sdW1uc1NlY3Rpb24gPSB0aGlzLmV4dHJhY3RDb2x1bW5EZWZpbml0aW9ucyhzdGF0ZW1lbnQpO1xuICAgIGNvbnN0IGNvbHVtbnMgPSB0aGlzLnBhcnNlQ29sdW1ucyhjb2x1bW5zU2VjdGlvbiwgc3RhdGVtZW50KTtcbiAgICBcbiAgICAvLyBFeHRyYWN0IHRhYmxlIGNvbW1lbnQgaWYgcHJlc2VudFxuICAgIGNvbnN0IGNvbW1lbnRNYXRjaCA9IHN0YXRlbWVudC5tYXRjaCgvQ09NTUVOVFxccyo9XFxzKicoW14nXSopJy9pKTtcbiAgICBjb25zdCBjb21tZW50ID0gY29tbWVudE1hdGNoID8gY29tbWVudE1hdGNoWzFdLnJlcGxhY2UoLycnLywgXCInXCIpIDogJyc7XG4gICAgXG4gICAgLy8gRXh0cmFjdCB0YWdzIGlmIHByZXNlbnRcbiAgICBjb25zdCB0YWdzTWF0Y2ggPSBzdGF0ZW1lbnQubWF0Y2goL1dJVEhcXHMrVEFHXFxzK1xcKChbXildKilcXCkvaSk7XG4gICAgbGV0IHRhZ3M6IHN0cmluZ1tdID0gW107XG4gICAgXG4gICAgaWYgKHRhZ3NNYXRjaCkge1xuICAgICAgY29uc3QgdGFnc1RleHQgPSB0YWdzTWF0Y2hbMV07XG4gICAgICAvLyBFeHRyYWN0IHRhZyBuYW1lcyBmcm9tIHRhZyBleHByZXNzaW9ucyBsaWtlICd0YWcxJyA9ICd0cnVlJ1xuICAgICAgY29uc3QgdGFnUmVnZXggPSAvJyhbXiddKyknXFxzKj1cXHMqJ3RydWUnL2c7XG4gICAgICBsZXQgdGFnTWF0Y2g7XG4gICAgICB3aGlsZSAoKHRhZ01hdGNoID0gdGFnUmVnZXguZXhlYyh0YWdzVGV4dCkpICE9PSBudWxsKSB7XG4gICAgICAgIHRhZ3MucHVzaCh0YWdNYXRjaFsxXSk7XG4gICAgICB9XG4gICAgfVxuICAgIFxuICAgIC8vIENyZWF0ZSB0aGUgbm9kZVxuICAgIGNvbnN0IG5vZGVJZCA9IGB0YWJsZS0ke3V1aWR2NCgpfWA7XG4gICAgdGhpcy50YWJsZU5hbWVzLnNldChub3JtYWxpemVkVGFibGVOYW1lLCBub2RlSWQpO1xuICAgIFxuICAgIGNvbnN0IG5vZGU6IEVSRE5vZGUgPSB7XG4gICAgICBpZDogbm9kZUlkLFxuICAgICAgdHlwZTogJ3RhYmxlJyxcbiAgICAgIHBvc2l0aW9uOiB7XG4gICAgICAgIHg6IE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIDUwMCksXG4gICAgICAgIHk6IE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIDMwMCksXG4gICAgICB9LFxuICAgICAgZGF0YToge1xuICAgICAgICBsYWJlbDogZnVsbFRhYmxlTmFtZSxcbiAgICAgICAgY29sdW1ucyxcbiAgICAgICAgdGFibGVUeXBlOiB0YWJsZVR5cGUgYXMgYW55LFxuICAgICAgICBjb21tZW50LFxuICAgICAgICB0YWdzXG4gICAgICB9XG4gICAgfTtcbiAgICBcbiAgICB0aGlzLm5vZGVzLnB1c2gobm9kZSk7XG4gIH1cblxuICAvKipcbiAgICogRXh0cmFjdCBjb2x1bW4gZGVmaW5pdGlvbnMgc2VjdGlvbiBmcm9tIENSRUFURSBUQUJMRSBzdGF0ZW1lbnRcbiAgICovXG4gIHByaXZhdGUgZXh0cmFjdENvbHVtbkRlZmluaXRpb25zKHN0YXRlbWVudDogc3RyaW5nKTogc3RyaW5nIHtcbiAgICAvLyBHZXQgY29udGVudCBiZXR3ZWVuIHRoZSBmaXJzdCAoIGFuZCB0aGUgbWF0Y2hpbmcgKVxuICAgIGNvbnN0IHN0YXJ0SWR4ID0gc3RhdGVtZW50LmluZGV4T2YoJygnKTtcbiAgICBpZiAoc3RhcnRJZHggPT09IC0xKSByZXR1cm4gJyc7XG4gICAgXG4gICAgbGV0IGRlcHRoID0gMTtcbiAgICBsZXQgZW5kSWR4ID0gc3RhcnRJZHggKyAxO1xuICAgIFxuICAgIGZvciAobGV0IGkgPSBzdGFydElkeCArIDE7IGkgPCBzdGF0ZW1lbnQubGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmIChzdGF0ZW1lbnRbaV0gPT09ICcoJykgZGVwdGgrKztcbiAgICAgIGVsc2UgaWYgKHN0YXRlbWVudFtpXSA9PT0gJyknKSBkZXB0aC0tO1xuICAgICAgXG4gICAgICBpZiAoZGVwdGggPT09IDApIHtcbiAgICAgICAgZW5kSWR4ID0gaTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICAgIFxuICAgIHJldHVybiBzdGF0ZW1lbnQuc3Vic3RyaW5nKHN0YXJ0SWR4ICsgMSwgZW5kSWR4KS50cmltKCk7XG4gIH1cblxuICAvKipcbiAgICogUGFyc2UgY29sdW1uIGRlZmluaXRpb25zIGludG8gQ29sdW1uIG9iamVjdHNcbiAgICovXG4gIHByaXZhdGUgcGFyc2VDb2x1bW5zKGNvbHVtbnNTZWN0aW9uOiBzdHJpbmcsIGZ1bGxTdGF0ZW1lbnQ6IHN0cmluZyk6IENvbHVtbltdIHtcbiAgICBjb25zdCBjb2x1bW5zOiBDb2x1bW5bXSA9IFtdO1xuICAgIGNvbnN0IGxpbmVzID0gY29sdW1uc1NlY3Rpb24uc3BsaXQoJyxcXG4nKS5tYXAobGluZSA9PiBsaW5lLnRyaW0oKSk7XG4gICAgXG4gICAgbGV0IHByaW1hcnlLZXlDb2x1bW5zOiBzdHJpbmdbXSA9IFtdO1xuICAgIFxuICAgIC8vIEV4dHJhY3QgcHJpbWFyeSBrZXkgY29uc3RyYWludCBpZiBwcmVzZW50XG4gICAgY29uc3QgcHJpbWFyeUtleU1hdGNoID0gY29sdW1uc1NlY3Rpb24ubWF0Y2goL1BSSU1BUllcXHMrS0VZXFxzKlxcKChbXildKylcXCkvaSk7XG4gICAgaWYgKHByaW1hcnlLZXlNYXRjaCkge1xuICAgICAgcHJpbWFyeUtleUNvbHVtbnMgPSBwcmltYXJ5S2V5TWF0Y2hbMV1cbiAgICAgICAgLnNwbGl0KCcsJylcbiAgICAgICAgLm1hcChjb2wgPT4gY29sLnRyaW0oKS5yZXBsYWNlKC9cIi9nLCAnJykudG9VcHBlckNhc2UoKSk7XG4gICAgfVxuICAgIFxuICAgIC8vIFByb2Nlc3MgZWFjaCBjb2x1bW4gZGVmaW5pdGlvblxuICAgIGZvciAoY29uc3QgbGluZSBvZiBsaW5lcykge1xuICAgICAgLy8gU2tpcCBpZiBsaW5lIGlzIGEgY29uc3RyYWludCBkZWZpbml0aW9uXG4gICAgICBpZiAoL14oUFJJTUFSWXxGT1JFSUdOfFVOSVFVRSlcXHMrS0VZL2kudGVzdChsaW5lKSkgY29udGludWU7XG4gICAgICBcbiAgICAgIC8vIEV4dHJhY3QgY29sdW1uIG5hbWVcbiAgICAgIGNvbnN0IG5hbWVNYXRjaCA9IGxpbmUubWF0Y2goL14oPzpcIihbXlwiXSspXCJ8KFthLXpBLVowLTlfXSspKVxccysvKTtcbiAgICAgIGlmICghbmFtZU1hdGNoKSBjb250aW51ZTtcbiAgICAgIFxuICAgICAgY29uc3QgbmFtZSA9IG5hbWVNYXRjaFsxXSB8fCBuYW1lTWF0Y2hbMl07XG4gICAgICBcbiAgICAgIC8vIEV4dHJhY3QgZGF0YSB0eXBlXG4gICAgICBjb25zdCB0eXBlTWF0Y2ggPSBsaW5lLm1hdGNoKC9cXHMrKFthLXpBLVowLTlfXSsoXFwoW14pXStcXCkpPykvKTtcbiAgICAgIGNvbnN0IGRhdGFUeXBlID0gdHlwZU1hdGNoID8gdHlwZU1hdGNoWzFdIDogJ1ZBUkNIQVInO1xuICAgICAgXG4gICAgICAvLyBDaGVjayBpZiBjb2x1bW4gaXMgbnVsbGFibGVcbiAgICAgIGNvbnN0IGlzTnVsbGFibGUgPSAhL05PVFxccytOVUxML2kudGVzdChsaW5lKTtcbiAgICAgIFxuICAgICAgLy8gQ2hlY2sgaWYgY29sdW1uIGlzIGEgcHJpbWFyeSBrZXlcbiAgICAgIGNvbnN0IGlzUHJpbWFyeUtleSA9IHByaW1hcnlLZXlDb2x1bW5zLmluY2x1ZGVzKG5hbWUudG9VcHBlckNhc2UoKSk7XG4gICAgICBcbiAgICAgIC8vIEV4dHJhY3QgY29tbWVudCBpZiBwcmVzZW50XG4gICAgICBjb25zdCBjb21tZW50TWF0Y2ggPSBsaW5lLm1hdGNoKC9DT01NRU5UXFxzKycoW14nXSopJy9pKTtcbiAgICAgIGNvbnN0IGNvbW1lbnQgPSBjb21tZW50TWF0Y2ggPyBjb21tZW50TWF0Y2hbMV0ucmVwbGFjZSgvJycvLCBcIidcIikgOiAnJztcbiAgICAgIFxuICAgICAgLy8gUGFyc2UgY29sdW1uLWxldmVsIHRhZ3MgZnJvbSBmdWxsIHN0YXRlbWVudFxuICAgICAgbGV0IHRhZ3M6IHN0cmluZ1tdID0gW107XG4gICAgICBjb25zdCB0YWdSZWdleCA9IG5ldyBSZWdFeHAoYEFMVEVSXFxcXHMrVEFCTEUuKk1PRElGWVxcXFxzK0NPTFVNTlxcXFxzKyg/OlwiJHtuYW1lfVwifCR7bmFtZX0pXFxcXHMrU0VUXFxcXHMrVEFHXFxcXHMrKFteO10rKWAsICdpJyk7XG4gICAgICBjb25zdCB0YWdzTWF0Y2ggPSBmdWxsU3RhdGVtZW50Lm1hdGNoKHRhZ1JlZ2V4KTtcbiAgICAgIFxuICAgICAgaWYgKHRhZ3NNYXRjaCkge1xuICAgICAgICBjb25zdCB0YWdzVGV4dCA9IHRhZ3NNYXRjaFsxXTtcbiAgICAgICAgLy8gRXh0cmFjdCB0YWcgbmFtZXMgZnJvbSB0YWcgZXhwcmVzc2lvbnNcbiAgICAgICAgY29uc3QgdGFnTmFtZVJlZ2V4ID0gLycoW14nXSspJ1xccyo9XFxzKid0cnVlJy9nO1xuICAgICAgICBsZXQgdGFnTWF0Y2g7XG4gICAgICAgIHdoaWxlICgodGFnTWF0Y2ggPSB0YWdOYW1lUmVnZXguZXhlYyh0YWdzVGV4dCkpICE9PSBudWxsKSB7XG4gICAgICAgICAgdGFncy5wdXNoKHRhZ01hdGNoWzFdKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgXG4gICAgICBjb2x1bW5zLnB1c2goe1xuICAgICAgICBpZDogdXVpZHY0KCksXG4gICAgICAgIG5hbWUsXG4gICAgICAgIGRhdGFUeXBlLFxuICAgICAgICBpc1ByaW1hcnlLZXksXG4gICAgICAgIGlzRm9yZWlnbktleTogZmFsc2UsIC8vIFdpbGwgYmUgc2V0IGluIHNlY29uZCBwYXNzXG4gICAgICAgIGlzTnVsbGFibGUsXG4gICAgICAgIGNvbW1lbnQsXG4gICAgICAgIHRhZ3NcbiAgICAgIH0pO1xuICAgIH1cbiAgICBcbiAgICByZXR1cm4gY29sdW1ucztcbiAgfVxuXG4gIC8qKlxuICAgKiBQYXJzZSBhIGZvcmVpZ24ga2V5IGNvbnN0cmFpbnQgYW5kIGNyZWF0ZSByZWxhdGlvbnNoaXBzXG4gICAqL1xuICBwcml2YXRlIHBhcnNlRm9yZWlnbktleUNvbnN0cmFpbnQoc3RhdGVtZW50OiBzdHJpbmcpOiB2b2lkIHtcbiAgICAvLyBFeHRyYWN0IHNvdXJjZSB0YWJsZSBuYW1lIChtYXkgYmUgZnVsbHkgcXVhbGlmaWVkKVxuICAgIGNvbnN0IHRhYmxlTWF0Y2ggPSBzdGF0ZW1lbnQubWF0Y2goL0FMVEVSXFxzK1RBQkxFXFxzKyg/OlwiKFteXCJdKyg/OlxcLlteXCJdKykqPylcInwoW2EtekEtWjAtOV9dKyg/OlxcLlthLXpBLVowLTlfXSspKikpL2kpO1xuICAgIGlmICghdGFibGVNYXRjaCkgcmV0dXJuO1xuICAgIFxuICAgIC8vIEdldCB0aGUgZnVsbCBuYW1lIGFuZCBleHRyYWN0IGp1c3QgdGhlIHRhYmxlIHBhcnQgZm9yIGxvb2t1cFxuICAgIGNvbnN0IGZ1bGxTb3VyY2VOYW1lID0gKHRhYmxlTWF0Y2hbMV0gfHwgdGFibGVNYXRjaFsyXSk7XG4gICAgY29uc3Qgc291cmNlUGFydHMgPSBmdWxsU291cmNlTmFtZS5zcGxpdCgnLicpO1xuICAgIGNvbnN0IHRhYmxlTmFtZSA9IHNvdXJjZVBhcnRzW3NvdXJjZVBhcnRzLmxlbmd0aCAtIDFdLnRvVXBwZXJDYXNlKCk7XG4gICAgXG4gICAgLy8gRXh0cmFjdCBzb3VyY2UgY29sdW1uc1xuICAgIGNvbnN0IHNvdXJjZUNvbHNNYXRjaCA9IHN0YXRlbWVudC5tYXRjaCgvRk9SRUlHTlxccytLRVlcXHMqXFwoKFteKV0rKVxcKS9pKTtcbiAgICBpZiAoIXNvdXJjZUNvbHNNYXRjaCkgcmV0dXJuO1xuICAgIFxuICAgIGNvbnN0IHNvdXJjZUNvbHMgPSBzb3VyY2VDb2xzTWF0Y2hbMV1cbiAgICAgIC5zcGxpdCgnLCcpXG4gICAgICAubWFwKGNvbCA9PiBjb2wudHJpbSgpLnJlcGxhY2UoL1wiL2csICcnKS50b1VwcGVyQ2FzZSgpKTtcbiAgICBcbiAgICAvLyBFeHRyYWN0IHRhcmdldCB0YWJsZSBhbmQgY29sdW1uc1xuICAgIGNvbnN0IHJlZnNNYXRjaCA9IHN0YXRlbWVudC5tYXRjaCgvUkVGRVJFTkNFU1xccysoPzpcIihbXlwiXSsoPzpcXC5bXlwiXSspKj8pXCJ8KFthLXpBLVowLTlfXSsoPzpcXC5bYS16QS1aMC05X10rKSopKVxccypcXCgoW14pXSspXFwpL2kpO1xuICAgIGlmICghcmVmc01hdGNoKSByZXR1cm47XG4gICAgXG4gICAgLy8gR2V0IHRoZSBmdWxsIHRhcmdldCBuYW1lIGFuZCBleHRyYWN0IGp1c3QgdGhlIHRhYmxlIHBhcnQgZm9yIGxvb2t1cFxuICAgIGNvbnN0IGZ1bGxUYXJnZXROYW1lID0gKHJlZnNNYXRjaFsxXSB8fCByZWZzTWF0Y2hbMl0pO1xuICAgIGNvbnN0IHRhcmdldFBhcnRzID0gZnVsbFRhcmdldE5hbWUuc3BsaXQoJy4nKTtcbiAgICBjb25zdCB0YXJnZXRUYWJsZSA9IHRhcmdldFBhcnRzW3RhcmdldFBhcnRzLmxlbmd0aCAtIDFdLnRvVXBwZXJDYXNlKCk7XG4gICAgXG4gICAgY29uc3QgdGFyZ2V0Q29scyA9IHJlZnNNYXRjaFszXVxuICAgICAgLnNwbGl0KCcsJylcbiAgICAgIC5tYXAoY29sID0+IGNvbC50cmltKCkucmVwbGFjZSgvXCIvZywgJycpLnRvVXBwZXJDYXNlKCkpO1xuICAgIFxuICAgIC8vIEZpbmQgbWF0Y2hpbmcgc291cmNlIGFuZCB0YXJnZXQgbm9kZXNcbiAgICBsZXQgc291cmNlTm9kZSA9IG51bGw7XG4gICAgbGV0IHRhcmdldE5vZGUgPSBudWxsO1xuICAgIGxldCBzb3VyY2VJZCA9ICcnO1xuICAgIGxldCB0YXJnZXRJZCA9ICcnO1xuICAgIFxuICAgIC8vIEZpcnN0IHRyeSBleGFjdCBtYXRjaCB1c2luZyB0aGUgdGFibGVOYW1lcyBtYXBcbiAgICBpZiAodGhpcy50YWJsZU5hbWVzLmhhcyh0YWJsZU5hbWUpICYmIHRoaXMudGFibGVOYW1lcy5oYXModGFyZ2V0VGFibGUpKSB7XG4gICAgICBzb3VyY2VJZCA9IHRoaXMudGFibGVOYW1lcy5nZXQodGFibGVOYW1lKSE7XG4gICAgICB0YXJnZXRJZCA9IHRoaXMudGFibGVOYW1lcy5nZXQodGFyZ2V0VGFibGUpITtcbiAgICAgIHNvdXJjZU5vZGUgPSB0aGlzLm5vZGVzLmZpbmQobm9kZSA9PiBub2RlLmlkID09PSBzb3VyY2VJZCk7XG4gICAgICB0YXJnZXROb2RlID0gdGhpcy5ub2Rlcy5maW5kKG5vZGUgPT4gbm9kZS5pZCA9PT0gdGFyZ2V0SWQpO1xuICAgIH1cbiAgICBcbiAgICAvLyBJZiB0aGF0IGZhaWxzLCB0cnkgbWF0Y2hpbmcgYnkgbGFiZWwgKHdoaWNoIG1heSBpbmNsdWRlIGZ1bGwgcGF0aHMpXG4gICAgaWYgKCFzb3VyY2VOb2RlIHx8ICF0YXJnZXROb2RlKSB7XG4gICAgICBmb3IgKGNvbnN0IG5vZGUgb2YgdGhpcy5ub2Rlcykge1xuICAgICAgICBpZiAobm9kZS50eXBlID09PSAndGFibGUnKSB7XG4gICAgICAgICAgY29uc3Qgbm9kZUxhYmVsID0gbm9kZS5kYXRhLmxhYmVsLnRvVXBwZXJDYXNlKCk7XG4gICAgICAgICAgXG4gICAgICAgICAgLy8gQ2hlY2sgaWYgbm9kZSBsYWJlbCBtYXRjaGVzIGZ1bGwgc291cmNlIG5hbWVcbiAgICAgICAgICBpZiAoIXNvdXJjZU5vZGUgJiYgKG5vZGVMYWJlbCA9PT0gZnVsbFNvdXJjZU5hbWUudG9VcHBlckNhc2UoKSB8fCBcbiAgICAgICAgICAgICAgbm9kZUxhYmVsLmVuZHNXaXRoKCcuJyArIHRhYmxlTmFtZSkpKSB7XG4gICAgICAgICAgICBzb3VyY2VOb2RlID0gbm9kZTtcbiAgICAgICAgICAgIHNvdXJjZUlkID0gbm9kZS5pZDtcbiAgICAgICAgICB9XG4gICAgICAgICAgXG4gICAgICAgICAgLy8gQ2hlY2sgaWYgbm9kZSBsYWJlbCBtYXRjaGVzIGZ1bGwgdGFyZ2V0IG5hbWVcbiAgICAgICAgICBpZiAoIXRhcmdldE5vZGUgJiYgKG5vZGVMYWJlbCA9PT0gZnVsbFRhcmdldE5hbWUudG9VcHBlckNhc2UoKSB8fCBcbiAgICAgICAgICAgICAgbm9kZUxhYmVsLmVuZHNXaXRoKCcuJyArIHRhcmdldFRhYmxlKSkpIHtcbiAgICAgICAgICAgIHRhcmdldE5vZGUgPSBub2RlO1xuICAgICAgICAgICAgdGFyZ2V0SWQgPSBub2RlLmlkO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBcbiAgICAvLyBJZiB3ZSBoYXZlIGJvdGggc291cmNlIGFuZCB0YXJnZXQgbm9kZXNcbiAgICBpZiAoc291cmNlTm9kZSAmJiB0YXJnZXROb2RlICYmIHNvdXJjZU5vZGUudHlwZSA9PT0gJ3RhYmxlJyAmJiB0YXJnZXROb2RlLnR5cGUgPT09ICd0YWJsZScpIHtcbiAgICAgIC8vIFVwZGF0ZSBzb3VyY2UgY29sdW1ucyB0byBtYXJrIHRoZW0gYXMgZm9yZWlnbiBrZXlzXG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHNvdXJjZUNvbHMubGVuZ3RoICYmIGkgPCB0YXJnZXRDb2xzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IGNvbHVtbk5hbWUgPSBzb3VyY2VDb2xzW2ldO1xuICAgICAgICBjb25zdCBjb2x1bW4gPSBzb3VyY2VOb2RlLmRhdGEuY29sdW1ucy5maW5kKFxuICAgICAgICAgIChjb2w6IENvbHVtbikgPT4gY29sLm5hbWUudG9VcHBlckNhc2UoKSA9PT0gY29sdW1uTmFtZVxuICAgICAgICApO1xuICAgICAgICBcbiAgICAgICAgaWYgKGNvbHVtbikge1xuICAgICAgICAgIGNvbHVtbi5pc0ZvcmVpZ25LZXkgPSB0cnVlO1xuICAgICAgICAgIGNvbHVtbi5yZWZlcmVuY2VkVGFibGUgPSB0YXJnZXROb2RlLmRhdGEubGFiZWw7IC8vIFVzZSBmdWxsIGxhYmVsXG4gICAgICAgICAgY29sdW1uLnJlZmVyZW5jZWRDb2x1bW4gPSB0YXJnZXRDb2xzW2ldO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBcbiAgICAgIC8vIENyZWF0ZSBhbiBlZGdlIGJldHdlZW4gdGhlIHRhYmxlc1xuICAgICAgY29uc3QgZWRnZTogRWRnZVR5cGUgPSB7XG4gICAgICAgIGlkOiBgZSR7c291cmNlSWR9LSR7dGFyZ2V0SWR9LSR7dXVpZHY0KCl9YCxcbiAgICAgICAgc291cmNlOiBzb3VyY2VJZCxcbiAgICAgICAgdGFyZ2V0OiB0YXJnZXRJZCxcbiAgICAgICAgc291cmNlSGFuZGxlOiAnJyxcbiAgICAgICAgdGFyZ2V0SGFuZGxlOiAnJyxcbiAgICAgICAgdHlwZTogJ3JlbGF0aW9uc2hpcCcsXG4gICAgICAgIGRhdGE6IHsgcmVsYXRpb25zaGlwVHlwZTogJ29uZS10by1tYW55JyB9XG4gICAgICB9O1xuICAgICAgXG4gICAgICB0aGlzLmVkZ2VzLnB1c2goZWRnZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnNvbGUud2FybihgQ291bGQgbm90IGNyZWF0ZSByZWxhdGlvbnNoaXAgYmV0d2VlbiAke2Z1bGxTb3VyY2VOYW1lfSBhbmQgJHtmdWxsVGFyZ2V0TmFtZX0gLSB0YWJsZXMgbm90IGZvdW5kYCk7XG4gICAgfVxuICB9XG59ICJdLCJuYW1lcyI6WyJ2NCIsInV1aWR2NCIsIkRETFBhcnNlciIsInBhcnNlIiwic3RhdGVtZW50cyIsInNwbGl0U3RhdGVtZW50cyIsImRkbCIsImNvbnNvbGUiLCJsb2ciLCJsZW5ndGgiLCJzdGF0ZW1lbnQiLCJpc0NyZWF0ZVRhYmxlU3RhdGVtZW50IiwicGFyc2VDcmVhdGVUYWJsZSIsImlzQWx0ZXJUYWJsZUFkZEZvcmVpZ25LZXkiLCJwYXJzZUZvcmVpZ25LZXlDb25zdHJhaW50Iiwibm9kZXMiLCJlZGdlcyIsImN1cnJlbnRTdGF0ZW1lbnQiLCJpblF1b3RlIiwicXVvdGVDaGFyIiwiaW5Db21tZW50IiwiaSIsImNoYXIiLCJuZXh0Q2hhciIsInRyaW0iLCJwdXNoIiwiZmlsdGVyIiwic3RtdCIsInRlc3QiLCJ0eXBlTWF0Y2giLCJtYXRjaCIsInRhYmxlVHlwZSIsInRvVXBwZXJDYXNlIiwicXVhbGlmaWVkTmFtZVJlZ2V4IiwibmFtZU1hdGNoIiwiZnVsbFRhYmxlTmFtZSIsInRhYmxlTmFtZSIsInBhcnRzIiwic3BsaXQiLCJkYlBhcnQiLCJzY2hlbWFQYXJ0IiwidGFibGVOYW1lUGFydCIsIm5vcm1hbGl6ZWRUYWJsZU5hbWUiLCJjb2x1bW5zU2VjdGlvbiIsImV4dHJhY3RDb2x1bW5EZWZpbml0aW9ucyIsImNvbHVtbnMiLCJwYXJzZUNvbHVtbnMiLCJjb21tZW50TWF0Y2giLCJjb21tZW50IiwicmVwbGFjZSIsInRhZ3NNYXRjaCIsInRhZ3MiLCJ0YWdzVGV4dCIsInRhZ1JlZ2V4IiwidGFnTWF0Y2giLCJleGVjIiwibm9kZUlkIiwidGFibGVOYW1lcyIsInNldCIsIm5vZGUiLCJpZCIsInR5cGUiLCJwb3NpdGlvbiIsIngiLCJNYXRoIiwiZmxvb3IiLCJyYW5kb20iLCJ5IiwiZGF0YSIsImxhYmVsIiwic3RhcnRJZHgiLCJpbmRleE9mIiwiZGVwdGgiLCJlbmRJZHgiLCJzdWJzdHJpbmciLCJmdWxsU3RhdGVtZW50IiwibGluZXMiLCJtYXAiLCJsaW5lIiwicHJpbWFyeUtleUNvbHVtbnMiLCJwcmltYXJ5S2V5TWF0Y2giLCJjb2wiLCJuYW1lIiwiZGF0YVR5cGUiLCJpc051bGxhYmxlIiwiaXNQcmltYXJ5S2V5IiwiaW5jbHVkZXMiLCJSZWdFeHAiLCJ0YWdOYW1lUmVnZXgiLCJpc0ZvcmVpZ25LZXkiLCJ0YWJsZU1hdGNoIiwiZnVsbFNvdXJjZU5hbWUiLCJzb3VyY2VQYXJ0cyIsInNvdXJjZUNvbHNNYXRjaCIsInNvdXJjZUNvbHMiLCJyZWZzTWF0Y2giLCJmdWxsVGFyZ2V0TmFtZSIsInRhcmdldFBhcnRzIiwidGFyZ2V0VGFibGUiLCJ0YXJnZXRDb2xzIiwic291cmNlTm9kZSIsInRhcmdldE5vZGUiLCJzb3VyY2VJZCIsInRhcmdldElkIiwiaGFzIiwiZ2V0IiwiZmluZCIsIm5vZGVMYWJlbCIsImVuZHNXaXRoIiwiY29sdW1uTmFtZSIsImNvbHVtbiIsInJlZmVyZW5jZWRUYWJsZSIsInJlZmVyZW5jZWRDb2x1bW4iLCJlZGdlIiwic291cmNlIiwidGFyZ2V0Iiwic291cmNlSGFuZGxlIiwidGFyZ2V0SGFuZGxlIiwicmVsYXRpb25zaGlwVHlwZSIsIndhcm4iLCJjb25zdHJ1Y3RvciIsIk1hcCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./app/utils/DDLParser.ts\n"));

/***/ })

});